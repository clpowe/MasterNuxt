#!/usr/bin/env node
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
exports.checkPeerDependencies = void 0;
var semver = require("semver");
var shelljs_1 = require("shelljs");
var packageManager_1 = require("./packageManager");
var packageUtils_1 = require("./packageUtils");
var solution_1 = require("./solution");
function getAllNestedPeerDependencies(options) {
    var gatheredDependencies = packageUtils_1.gatherPeerDependencies(".", options);
    function applySemverInformation(dep) {
        var installedVersion = packageUtils_1.getInstalledVersion(dep);
        var semverSatisfies = installedVersion ? semver.satisfies(installedVersion, dep.version, { includePrerelease: true }) : false;
        var isYalc = !!/-[a-f0-9]+-yalc$/.exec(installedVersion);
        return __assign(__assign({}, dep), { installedVersion: installedVersion, semverSatisfies: semverSatisfies, isYalc: isYalc });
    }
    return gatheredDependencies.map(applySemverInformation);
}
var recursiveCount = 0;
var reportPeerDependencyStatus = function (dep, byDepender, showSatisfiedDep, showOptionalDep) {
    var message = byDepender ?
        dep.depender.name + "@" + dep.depender.version + " requires " + dep.name + " " + dep.version :
        dep.name + " " + dep.version + " is required by " + dep.depender.name + "@" + dep.depender.version;
    if (dep.semverSatisfies) {
        if (showSatisfiedDep) {
            console.log("  \u2705  " + message + " (" + dep.installedVersion + " is installed)");
        }
    }
    else if (dep.isYalc) {
        console.log("  \u2611\uFE0F  " + message + " (" + dep.installedVersion + " is installed via yalc)");
    }
    else if (dep.installedVersion && dep.isPeerOptionalDependency) {
        if (showOptionalDep) {
            console.log("  \u2611\uFE0F  " + message + ") OPTIONAL (" + dep.installedVersion + " is installed)");
        }
    }
    else if (dep.installedVersion) {
        console.log("  \u274C  " + message + ") (" + dep.installedVersion + " is installed)");
    }
    else if (dep.isPeerOptionalDependency) {
        if (showOptionalDep) {
            console.log("  \u2611\uFE0F  " + message + " OPTIONAL (" + dep.name + " is not installed)");
        }
    }
    else {
        console.log("  \u274C  " + message + " (" + dep.name + " is not installed)");
    }
};
function findSolutions(problems, allNestedPeerDependencies) {
    console.log();
    console.log("Searching for solutions for " + problems.length + " missing dependencies...");
    console.log();
    var resolutions = solution_1.findPossibleResolutions(problems, allNestedPeerDependencies);
    var resolutionsWithSolutions = resolutions.filter(function (r) { return r.resolution; });
    var nosolution = resolutions.filter(function (r) { return !r.resolution; });
    nosolution.forEach(function (solution) {
        var name = solution.problem.name;
        var errorPrefix = "Unable to find a version of " + name + " that satisfies the following peerDependencies:";
        var peerDepRanges = allNestedPeerDependencies.filter(function (dep) { return dep.name === name; })
            .reduce(function (acc, dep) { return acc.includes(dep.version) ? acc : acc.concat(dep.version); }, []);
        console.error("  \u274C  " + errorPrefix + " " + peerDepRanges.join(" and "));
    });
    if (nosolution.length > 0) {
        console.error();
    }
    return { resolutionsWithSolutions: resolutionsWithSolutions, nosolution: nosolution };
}
function installPeerDependencies(commandLines, options, nosolution, packageManager) {
    console.log('Installing peerDependencies...');
    console.log();
    commandLines.forEach(function (command) {
        console.log("$ " + command);
        shelljs_1.exec(command);
        console.log();
    });
    var newUnsatisfiedDeps = getAllNestedPeerDependencies(options)
        .filter(function (dep) { return !dep.semverSatisfies; })
        .filter(function (dep) { return !nosolution.some(function (x) { return packageUtils_1.isSameDep(x.problem, dep); }); });
    if (nosolution.length === 0 && newUnsatisfiedDeps.length === 0) {
        console.log('All peer dependencies are met');
    }
    if (newUnsatisfiedDeps.length > 0) {
        console.log("Found " + newUnsatisfiedDeps.length + " new unmet peerDependencies...");
        if (++recursiveCount < 5) {
            return checkPeerDependencies(packageManager, options);
        }
        else {
            console.error('Recursion limit reached (5)');
            process.exit(5);
        }
    }
    return;
}
function report(options, allNestedPeerDependencies) {
    if (options.orderBy === 'depender') {
        allNestedPeerDependencies.sort(function (a, b) { return ("" + a.depender + a.name).localeCompare("" + b.depender + b.name); });
    }
    else if (options.orderBy == 'dependee') {
        allNestedPeerDependencies.sort(function (a, b) { return ("" + a.name + a.depender).localeCompare("" + b.name + b.depender); });
    }
    allNestedPeerDependencies.forEach(function (dep) {
        var isUnsatisfied = function (dep) { return !dep.semverSatisfies && !dep.isYalc; };
        var relatedPeerDeps = allNestedPeerDependencies.filter(function (other) { return other.name === dep.name && other !== dep; });
        var showIfSatisfied = options.verbose || relatedPeerDeps.some(isUnsatisfied);
        var showOptionalDep = options.verbose;
        reportPeerDependencyStatus(dep, options.orderBy === 'depender', showIfSatisfied, showOptionalDep);
    });
}
function checkPeerDependencies(packageManager, options) {
    var allNestedPeerDependencies = getAllNestedPeerDependencies(options);
    report(options, allNestedPeerDependencies);
    var problems = allNestedPeerDependencies.filter(function (dep) { return !dep.semverSatisfies && !dep.isYalc && !dep.isPeerOptionalDependency; });
    if (!problems.length) {
        console.log('  âœ…  All peer dependencies are met');
        return;
    }
    if (options.install) {
        var _a = findSolutions(problems, allNestedPeerDependencies), nosolution = _a.nosolution, resolutionsWithSolutions = _a.resolutionsWithSolutions;
        var commandLines = packageManager_1.getCommandLines(packageManager, resolutionsWithSolutions);
        if (commandLines.length) {
            return installPeerDependencies(commandLines, options, nosolution, packageManager);
        }
    }
    else if (options.findSolutions) {
        var resolutionsWithSolutions = findSolutions(problems, allNestedPeerDependencies).resolutionsWithSolutions;
        var commandLines = packageManager_1.getCommandLines(packageManager, resolutionsWithSolutions);
        if (commandLines.length) {
            console.log();
            console.log("Install peerDependencies using " + (commandLines.length > 1 ? 'these commands:' : 'this command') + ":");
            console.log();
            commandLines.forEach(function (command) { return console.log(command); });
            console.log();
        }
    }
    else {
        console.log();
        console.log("Search for solutions using this command:");
        console.log();
        console.log("npx check-peer-dependencies --findSolutions");
        console.log();
        console.log("Install peerDependencies using this command:");
        console.log();
        console.log("npx check-peer-dependencies --install");
        console.log();
    }
    process.exit(1);
}
exports.checkPeerDependencies = checkPeerDependencies;
