#!/usr/bin/env node
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var path = require("path");
var semver = require("semver");
var shelljs_1 = require("shelljs");
var packageManager_1 = require("./packageManager");
var packageUtils_1 = require("./packageUtils");
var readJson_1 = require("./readJson");
var solution_1 = require("./solution");
function checkPeerDependencies(packageManager, installMissingPeerDependencies) {
    var allNestedPeerDependencies = packageUtils_1.gatherPeerDependencies(".").map(function (dep) {
        var installedVersion = getInstalledVersion(dep);
        var semverSatisfies = installedVersion ? semver.satisfies(installedVersion, dep.version) : false;
        return __assign(__assign({}, dep), { installedVersion: installedVersion, semverSatisfies: semverSatisfies });
    }).sort(function (a, b) { return ("" + a.name + a.depender).localeCompare("" + b.name + b.depender); });
    allNestedPeerDependencies.forEach(function (dep) {
        if (dep.semverSatisfies) {
            console.log("\u2705  " + dep.depender + " requires  " + dep.name + " " + dep.version + " and " + dep.installedVersion + " is installed");
        }
        else if (dep.installedVersion) {
            console.log("\u274C  " + dep.depender + " requires " + dep.name + " " + dep.version + ", but " + dep.name + " is not installed");
        }
        else {
            console.log("\u274C  " + dep.depender + " requires " + dep.name + " " + dep.version + ", but " + dep.installedVersion + " is installed");
        }
    });
    var problems = allNestedPeerDependencies.filter(function (dep) { return !dep.semverSatisfies && !/file:\.yalc/.exec(dep.dependerVersion); });
    if (!problems.length) {
        console.log('No problems found!');
        return;
    }
    console.log('Searching for solutions:');
    var resolutions = solution_1.findPossibleResolutions(problems, allNestedPeerDependencies);
    var installs = resolutions.filter(function (r) { return r.resolutionType === 'install'; }).map(function (r) { return r.resolution; });
    var upgrades = resolutions.filter(function (r) { return r.resolutionType === 'upgrade'; }).map(function (r) { return r.resolution; });
    var nosolution = resolutions.filter(function (r) { return !r.resolution; });
    nosolution.forEach(function (solution) {
        var name = solution.problem.name;
        var errorPrefix = "Unable to find a version of " + name + " that satisfies the following peerDependencies:";
        var peerDepRanges = allNestedPeerDependencies.filter(function (dep) { return dep.name === name; })
            .reduce(function (acc, dep) { return acc.includes(dep.version) ? acc : acc.concat(dep.version); }, []);
        console.error("\u274C\u274C\u274C  " + errorPrefix + " " + peerDepRanges.join(" and ") + "  \u274C\u274C\u274C");
    });
    var commandLines = packageManager_1.getCommandLines(packageManager, installs, upgrades);
    if (nosolution.length) {
        console.error();
    }
    if (installMissingPeerDependencies) {
        console.log('Installing peerDependencies...');
        commandLines.forEach(function (command) { return shelljs_1.exec(command); });
    }
    else {
        commandLines.forEach(function (command) { return console.log(command); });
        console.log();
    }
}
exports.checkPeerDependencies = checkPeerDependencies;
function getInstalledVersion(dep) {
    var peerDependencyDir = packageUtils_1.resolvePackageDir(".", dep.name);
    if (!peerDependencyDir) {
        return undefined;
    }
    var packageJson = readJson_1.readJson(path.resolve(peerDependencyDir, 'package.json'));
    return packageJson.version;
}
