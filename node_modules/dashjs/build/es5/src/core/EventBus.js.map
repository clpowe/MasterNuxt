{"version":3,"sources":["../../../../src/core/EventBus.js"],"names":["EVENT_PRIORITY_LOW","EVENT_PRIORITY_HIGH","EventBus","handlers","on","type","listener","scope","options","Error","priority","getHandlerIdx","handler","callback","getStreamId","streamId","getType","mediaType","mode","inserted","some","item","idx","splice","push","off","trigger","payload","filters","hasOwnProperty","filter","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","forEach","call","index","reset","instance","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"EventBus.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from './FactoryMaker';\nimport MediaPlayerEvents from '../streaming/MediaPlayerEvents';\n\nconst EVENT_PRIORITY_LOW = 0;\nconst EVENT_PRIORITY_HIGH = 5000;\n\nfunction EventBus() {\n\n    let handlers = {};\n\n    function on(type, listener, scope, options = {}) {\n\n        if (!type) {\n            throw new Error('event type cannot be null or undefined');\n        }\n        if (!listener || typeof (listener) !== 'function') {\n            throw new Error('listener must be a function: ' + listener);\n        }\n\n        let priority = options.priority || EVENT_PRIORITY_LOW;\n\n        if (getHandlerIdx(type, listener, scope) >= 0) return;\n\n        handlers[type] = handlers[type] || [];\n\n        const handler = {\n            callback: listener,\n            scope,\n            priority\n        };\n\n        if (scope && scope.getStreamId) {\n            handler.streamId = scope.getStreamId();\n        }\n        if (scope && scope.getType) {\n            handler.mediaType = scope.getType();\n        }\n        if (options && options.mode) {\n            handler.mode = options.mode;\n        }\n\n        const inserted = handlers[type].some((item, idx) => {\n            if (item && priority > item.priority) {\n                handlers[type].splice(idx, 0, handler);\n                return true;\n            }\n        });\n\n        if (!inserted) {\n            handlers[type].push(handler);\n        }\n    }\n\n    function off(type, listener, scope) {\n        if (!type || !listener || !handlers[type]) return;\n        const idx = getHandlerIdx(type, listener, scope);\n        if (idx < 0) return;\n        handlers[type][idx] = null;\n    }\n\n    function trigger(type, payload = {}, filters = {}) {\n        if (!type || !handlers[type]) return;\n\n        payload = payload || {};\n\n        if (payload.hasOwnProperty('type')) throw new Error('\\'type\\' is a reserved word for event dispatching');\n\n        payload.type = type;\n\n        if (filters.streamId) {\n            payload.streamId = filters.streamId;\n        }\n        if (filters.mediaType) {\n            payload.mediaType = filters.mediaType;\n        }\n\n        handlers[type]\n            .filter((handler) => {\n                if (!handler) {\n                    return false;\n                }\n                if (filters.streamId && handler.streamId && handler.streamId !== filters.streamId) {\n                    return false;\n                }\n                if (filters.mediaType && handler.mediaType && handler.mediaType !== filters.mediaType) {\n                    return false;\n                }\n                // This is used for dispatching DASH events. By default we use the onStart mode. Consequently we filter everything that has a non matching mode and the onReceive events for handlers that did not specify a mode.\n                if ((filters.mode && handler.mode && handler.mode !== filters.mode) || (!handler.mode && filters.mode && filters.mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE)) {\n                    return false;\n                }\n                return true;\n            })\n            .forEach(handler => handler && handler.callback.call(handler.scope, payload));\n    }\n\n    function getHandlerIdx(type, listener, scope) {\n\n        let idx = -1;\n\n        if (!handlers[type]) return idx;\n\n        handlers[type].some((item, index) => {\n            if (item && item.callback === listener && (!scope || scope === item.scope)) {\n                idx = index;\n                return true;\n            }\n        });\n        return idx;\n    }\n\n    function reset() {\n        handlers = {};\n    }\n\n    const instance = {\n        on: on,\n        off: off,\n        trigger: trigger,\n        reset: reset\n    };\n\n    return instance;\n}\n\nEventBus.__dashjs_factory_name = 'EventBus';\nconst factory = FactoryMaker.getSingletonFactory(EventBus);\nfactory.EVENT_PRIORITY_LOW = EVENT_PRIORITY_LOW;\nfactory.EVENT_PRIORITY_HIGH = EVENT_PRIORITY_HIGH;\nFactoryMaker.updateSingletonFactory(EventBus.__dashjs_factory_name, factory);\nexport default factory;\n"]}