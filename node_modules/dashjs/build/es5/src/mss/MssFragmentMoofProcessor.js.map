{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":["MssFragmentMoofProcessor","config","instance","type","logger","dashMetrics","playbackController","errorHandler","errHandler","eventBus","ISOBoxer","debug","setup","getLogger","processTfrf","request","tfrf","tfdt","streamProcessor","representationController","getRepresentationController","representation","getCurrentRepresentation","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","timescale","SegmentTemplate","getType","timeShiftBufferDepth","error","DashJSError","MssErrors","MSS_NO_TFRF_CODE","MSS_NO_TFRF_MESSAGE","segments","SegmentTimeline","S","entries","entry","segmentTime","range","segment","t","endTime","availabilityStartTime","length","tManifest","parseFloat","fragment_absolute_time","start","end","baseMediaDecodeTime","duration","updateDVR","mediaType","getStreamInfo","manifestInfo","d","fragment_duration","lastSegment","push","trigger","Events","MANIFEST_VALIDITY_CHANGED","sender","newDuration","isPaused","getTime","splice","updateRepresentation","dvrInfos","getCurrentDVRInfo","addDVRInfo","updateCurrentTime","getBoxOffset","parent","offset","i","boxes","size","convertFragment","e","isoFile","parseBuffer","response","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","Math","floor","startTime","trun","tfxd","_parent","indexOf","sepiff","usertype","undefined","saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","trafPosInMoof","sencPosInTraf","write","updateSegmentList","Error","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport DashJSError from '../streaming/vo/DashJSError';\nimport MssErrors from './errors/MssErrors';\n\nimport Events from '../streaming/MediaPlayerEvents';\n\n/**\n * @module MssFragmentMoofProcessor\n * @ignore\n * @param {Object} config object\n */\nfunction MssFragmentMoofProcessor(config) {\n\n    config = config || {};\n    let instance,\n        type,\n        logger;\n    const dashMetrics = config.dashMetrics;\n    const playbackController = config.playbackController;\n    const errorHandler = config.errHandler;\n    const eventBus = config.eventBus;\n    const ISOBoxer = config.ISOBoxer;\n    const debug = config.debug;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        type = '';\n    }\n\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\n        const representationController = streamProcessor.getRepresentationController();\n        const representation = representationController.getCurrentRepresentation();\n\n        const manifest = representation.adaptation.period.mpd.manifest;\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n        const timescale = adaptation.SegmentTemplate.timescale;\n\n        type = streamProcessor.getType();\n\n        // Process tfrf only for live streams or start-over static streams (timeShiftBufferDepth > 0)\n        if (manifest.type !== 'dynamic' && !manifest.timeShiftBufferDepth) {\n            return;\n        }\n\n        if (!tfrf) {\n            errorHandler.error(new DashJSError(MssErrors.MSS_NO_TFRF_CODE, MssErrors.MSS_NO_TFRF_MESSAGE));\n            return;\n        }\n\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S;\n        const entries = tfrf.entry;\n        let entry,\n            segmentTime,\n            range;\n        let segment = null;\n        let t = 0;\n        let endTime;\n        let availabilityStartTime = null;\n\n        if (entries.length === 0) {\n            return;\n        }\n\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\n        entry = entries[0];\n\n        // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)\n        // => then do not update anymore timeline\n        if (manifest.type === 'static') {\n            // Get first segment time\n            segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;\n            if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {\n                return;\n            }\n        }\n\n        // logger.debug('entry - t = ', (entry.fragment_absolute_time / timescale));\n\n        // Get last segment time\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\n        // logger.debug('Last segment - t = ', (segmentTime / timescale));\n\n        // Check if we have to append new segment to timeline\n        if (entry.fragment_absolute_time <= segmentTime) {\n            // Update DVR window range => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\n            return;\n        }\n\n        // logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale));\n        segment = {};\n        segment.t = entry.fragment_absolute_time;\n        segment.d = entry.fragment_duration;\n        // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time\n        if (segments[0].tManifest) {\n            segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;\n            segment.tManifest = entry.fragment_absolute_time;\n        }\n\n        // Patch previous segment duration\n        let lastSegment = segments[segments.length - 1];\n        if (lastSegment.t + lastSegment.d !== segment.t) {\n            logger.debug('Patch segment duration - t = ', lastSegment.t + ', d = ' + lastSegment.d + ' => ' + (segment.t - lastSegment.t));\n            lastSegment.d = segment.t - lastSegment.t;\n        }\n\n        segments.push(segment);\n\n        // In case of static start-over streams, update content duration\n        if (manifest.type === 'static') {\n            if (type === 'video') {\n                segment = segments[segments.length - 1];\n                endTime = (segment.t + segment.d) / timescale;\n                if (endTime > representation.adaptation.period.duration) {\n                    eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { sender: this, newDuration: endTime });\n                }\n            }\n            return;\n        }\n        else {\n            // In case of live streams, update segment timeline according to DVR window\n            if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n                // Get timestamp of the last segment\n                segment = segments[segments.length - 1];\n                t = segment.t;\n\n                // Determine the segments' availability start time\n                availabilityStartTime = (t - (manifest.timeShiftBufferDepth * timescale)) / timescale;\n\n                // Remove segments prior to availability start time\n                segment = segments[0];\n                endTime = (segment.t + segment.d) / timescale;\n                while (endTime < availabilityStartTime) {\n                    // Check if not currently playing the segment to be removed\n                    if (!playbackController.isPaused() && playbackController.getTime() < endTime) {\n                        break;\n                    }\n                    // logger.debug('Remove segment  - t = ' + (segment.t / timescale));\n                    segments.splice(0, 1);\n                    segment = segments[0];\n                    endTime =  (segment.t + segment.d) / timescale;\n                }\n            }\n\n            // Update DVR window range => set range end to end time of current segment\n            range = {\n                start: segments[0].t / timescale,\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\n            };\n\n            updateDVR(type, range, streamProcessor.getStreamInfo().manifestInfo);\n        }\n\n        representationController.updateRepresentation(representation, true);\n    }\n\n    function updateDVR(type, range, manifestInfo) {\n        if (type !== 'video' && type !== 'audio') return;\n        const dvrInfos = dashMetrics.getCurrentDVRInfo(type);\n        if (!dvrInfos || (range.end > dvrInfos.range.end)) {\n            logger.debug('Update DVR range: [' + range.start + ' - ' + range.end + ']');\n            dashMetrics.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\n            playbackController.updateCurrentTime(type);\n        }\n    }\n\n    // This function returns the offset of the 1st byte of a child box within a container box\n    function getBoxOffset(parent, type) {\n        let offset = 8;\n        let i = 0;\n\n        for (i = 0; i < parent.boxes.length; i++) {\n            if (parent.boxes[i].type === type) {\n                return offset;\n            }\n            offset += parent.boxes[i].size;\n        }\n        return offset;\n    }\n\n    function convertFragment(e, streamProcessor) {\n        let i;\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        const traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        const trun = isoFile.fetch('trun');\n\n        // Process tfxd boxes\n        // This box provide absolute timestamp but we take the segment start time for tfdt\n        let tfxd = isoFile.fetch('tfxd');\n        if (tfxd) {\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\n            tfxd = null;\n        }\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, streamProcessor);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n        // => convert sepiff box it into a senc box\n        // => create saio and saiz boxes (if not already present)\n        const sepiff = isoFile.fetch('sepiff');\n        if (sepiff !== null) {\n            sepiff.type = 'senc';\n            sepiff.usertype = undefined;\n\n            let saio = isoFile.fetch('saio');\n            if (saio === null) {\n                // Create Sample Auxiliary Information Offsets Box box (saio)\n                saio = ISOBoxer.createFullBox('saio', traf);\n                saio.version = 0;\n                saio.flags = 0;\n                saio.entry_count = 1;\n                saio.offset = [0];\n\n                const saiz = ISOBoxer.createFullBox('saiz', traf);\n                saiz.version = 0;\n                saiz.flags = 0;\n                saiz.sample_count = sepiff.sample_count;\n                saiz.default_sample_info_size = 0;\n                saiz.sample_info_size = [];\n\n                if (sepiff.flags & 0x02) {\n                    // Sub-sample encryption => set sample_info_size for each sample\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                    }\n                } else {\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                    saiz.default_sample_info_size = 8;\n                }\n            }\n        }\n\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\n\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\n        const moof = isoFile.fetch('moof');\n        let length = moof.getLength();\n        trun.data_offset = length + 8;\n\n        // Update saio box offset field according to new senc box offset\n        let saio = isoFile.fetch('saio');\n        if (saio !== null) {\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\n            // Set offset from begin fragment to the first IV field in senc box\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n        }\n\n        // Write transformed/processed fragment into request reponse data\n        e.response = isoFile.write();\n    }\n\n    function updateSegmentList(e, streamProcessor) {\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            throw new Error('e.response parameter is missing');\n        }\n\n        const isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        const tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let tfrf = isoFile.fetch('tfrf');\n        processTfrf(e.request, tfrf, tfdt, streamProcessor);\n        if (tfrf) {\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    instance = {\n        convertFragment: convertFragment,\n        updateSegmentList: updateSegmentList,\n        getType: getType\n    };\n\n    setup();\n    return instance;\n}\n\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\n"]}