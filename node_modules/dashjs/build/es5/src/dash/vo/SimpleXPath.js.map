{"version":3,"sources":["../../../../../src/dash/vo/SimpleXPath.js"],"names":["SimpleXPath","selector","valid","path","split","filter","component","length","map","parsed","name","qualifierPoint","indexOf","substring","qualifier","equalityPoint","attribute","value","position","parseInt","findsAttribute","startsWith","root","isSiblingOperation","parent","leaf","level","children","push","attr","elm","target"],"mappings":"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","file":"SimpleXPath.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n * @class\n * @ignore\n */\nclass SimpleXPath {\n    constructor(selector) {\n        // establish validation of the path, to catch unsupported cases\n        this.valid = selector[0] == '/'; // first check, we only support absolute addressing\n\n        // establish parsed path, example:\n        // /MPD/Period[@id=\"foobar\"]/AdaptationSet[@id=\"2\"]/SegmentTemplate/SegmentTimeline\n        this.path = selector.split('/')\n            .filter((component) => component.length !== 0) // remove excess empty components\n            .map((component) => {\n                let parsed = {\n                    name: component\n                };\n\n                let qualifierPoint = component.indexOf('[');\n                if (qualifierPoint != -1) {\n                    parsed.name = component.substring(0, qualifierPoint);\n\n                    let qualifier = component.substring(qualifierPoint + 1, component.length - 1);\n\n                    // quick sanity check are there additional qualifiers making this invalid\n                    this.valid = this.valid && qualifier.indexOf('[') == -1;\n\n                    let equalityPoint = qualifier.indexOf('=');\n                    if (equalityPoint != -1) {\n                        parsed.attribute = {\n                            name: qualifier.substring(1, equalityPoint), // skip the @\n                            value: qualifier.substring(equalityPoint + 1)\n                        };\n\n                        // check for single and double quoted attribute values\n                        if (['\\'', '\"'].indexOf(parsed.attribute.value[0]) != -1) {\n                            parsed.attribute.value = parsed.attribute.value.substring(1, parsed.attribute.value.length - 1);\n                        }\n                    } else {\n                        // positional access in xpath is 1-based index\n                        // internal processes will assume 0-based so we normalize that here\n                        parsed.position = parseInt(qualifier, 10) - 1;\n                    }\n                }\n\n                return parsed;\n            });\n    }\n\n    isValid() {\n        return this.valid;\n    }\n\n    findsElement() {\n        return !this.findsAttribute();\n    }\n\n    findsAttribute() {\n        return this.path[this.path.length - 1].name.startsWith('@');\n    }\n\n    getMpdTarget(root, isSiblingOperation) {\n        let parent = null;\n        let leaf = root;\n        // assume root is MPD and we start at next level match\n        let level = 1;\n        let name = 'MPD';\n\n        while ( level < this.path.length && leaf !== null) {\n            // set parent to current\n            parent = leaf;\n\n            // select next leaf based on component\n            let component = this.path[level];\n            name = component.name;\n\n            // stop one early if this is the last element and an attribute\n            if (level !== this.path.length - 1 || !name.startsWith('@')) {\n                let children = parent[name + '_asArray'] || [];\n                if (children.length === 0 && parent[name]) {\n                    children.push(parent[name]);\n                }\n\n                if (component.position) {\n                    leaf = children[component.position] || null;\n                } else if (component.attribute) {\n                    let attr = component.attribute;\n                    leaf = children.filter((elm) => elm[attr.name] == attr.value)[0] || null;\n                } else {\n                    // default case, select first\n                    leaf = children[0] || null;\n                }\n            }\n\n            level++;\n        }\n\n        if (leaf === null) {\n            // given path not found in root\n            return null;\n        }\n\n        // attributes the target is the leaf node, the name is the attribute\n        if (name.startsWith('@')) {\n            return {\n                name: name.substring(1),\n                leaf: leaf,\n                target: leaf\n            };\n        }\n\n        // otherwise we target the parent for sibling operations and leaf for child operations\n        return {\n            name: name,\n            leaf: leaf,\n            target: isSiblingOperation ? parent : leaf\n        };\n    }\n}\n\nexport default SimpleXPath;\n"]}