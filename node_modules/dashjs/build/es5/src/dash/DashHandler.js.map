{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["DashHandler","config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","setup","getLogger","resetInitialSettings","create","on","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","DYNAMIC_TO_STATIC","onDynamicToStatic","initialize","isDynamic","getStreamId","id","getType","getStreamInfo","setCurrentIndex","value","getCurrentIndex","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","initialization","bandwidth","getInitRequest","setMimeType","newMimeType","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","e","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","streamId","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","mediaStartTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","getSegmentByTime","finished","action","ACTION_COMPLETE","SEGMENT_TIMELINE","getNextSegmentRequestIdempotent","indexToRequest","getSegmentByIndex","getNextSegmentRequest","isEndlessMedia","isFinite","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"DashHandler.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\nimport {HTTPRequest} from '../streaming/vo/metrics/HTTPRequest';\nimport FactoryMaker from '../core/FactoryMaker';\nimport {\n    replaceIDForTemplate,\n    unescapeDollarsInTemplate,\n    replaceTokenForTemplate,\n    getTimeBasedSegment\n} from './utils/SegmentsUtils';\n\nimport SegmentsController from './controllers/SegmentsController';\n\nfunction DashHandler(config) {\n\n    config = config || {};\n    const context = this.context;\n\n    const eventBus = config.eventBus;\n    const events = config.events;\n    const debug = config.debug;\n    const dashConstants = config.dashConstants;\n    const urlUtils = config.urlUtils;\n    const type = config.type;\n    const streamInfo = config.streamInfo;\n\n    const timelineConverter = config.timelineConverter;\n    const dashMetrics = config.dashMetrics;\n    const baseURLController = config.baseURLController;\n\n    let instance,\n        logger,\n        segmentIndex,\n        lastSegment,\n        requestedTime,\n        isDynamicManifest,\n        dynamicStreamCompleted,\n        selectedMimeType,\n        segmentsController;\n\n    function setup() {\n        logger = debug.getLogger(instance);\n        resetInitialSettings();\n\n        segmentsController = SegmentsController(context).create(config);\n\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.on(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function initialize(isDynamic) {\n        isDynamicManifest = isDynamic;\n        dynamicStreamCompleted = false;\n        segmentsController.initialize(isDynamic);\n    }\n\n    function getStreamId() {\n        return streamInfo.id;\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function getStreamInfo() {\n        return streamInfo;\n    }\n\n    function setCurrentIndex(value) {\n        segmentIndex = value;\n    }\n\n    function getCurrentIndex() {\n        return segmentIndex;\n    }\n\n    function resetIndex() {\n        segmentIndex = -1;\n        lastSegment = null;\n    }\n\n    function resetInitialSettings() {\n        resetIndex();\n        requestedTime = null;\n        segmentsController = null;\n        selectedMimeType = null;\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\n        eventBus.off(events.DYNAMIC_TO_STATIC, onDynamicToStatic, instance);\n    }\n\n    function setRequestUrl(request, destination, representation) {\n        const baseURL = baseURLController.resolve(representation.path);\n        let url,\n            serviceLocation;\n\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\n            url = destination;\n        } else {\n            url = baseURL.url;\n            serviceLocation = baseURL.serviceLocation;\n\n            if (destination) {\n                url = urlUtils.resolve(destination, url);\n            }\n        }\n\n        if (urlUtils.isRelative(url)) {\n            return false;\n        }\n\n        request.url = url;\n        request.serviceLocation = serviceLocation;\n\n        return true;\n    }\n\n    function generateInitRequest(mediaInfo, representation, mediaType) {\n        const request = new FragmentRequest();\n        const period = representation.adaptation.period;\n        const presentationStartTime = period.start;\n\n        request.mediaType = mediaType;\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\n        request.range = representation.range;\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\n        request.quality = representation.index;\n        request.mediaInfo = mediaInfo;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, representation.initialization, representation)) {\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\n            return request;\n        }\n    }\n\n    function getInitRequest(mediaInfo, representation) {\n        if (!representation) return null;\n        const request = generateInitRequest(mediaInfo, representation, getType());\n        return request;\n    }\n\n    function setMimeType(newMimeType) {\n        selectedMimeType = newMimeType;\n    }\n\n    function setExpectedLiveEdge(liveEdge) {\n        timelineConverter.setExpectedLiveEdge(liveEdge);\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\n    }\n\n    function onRepresentationUpdateStarted(e) {\n        processRepresentation(e.representation);\n    }\n\n    function processRepresentation(voRepresentation) {\n        const hasInitialization = voRepresentation.hasInitialization();\n        const hasSegments = voRepresentation.hasSegments();\n\n        // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\n        // otherwise, it means that a request has to be made to get initialization and/or segments informations\n        if (hasInitialization && hasSegments) {\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n                { representation: voRepresentation },\n                { streamId: streamInfo.id, mediaType: type }\n            );\n        } else {\n            segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\n        }\n    }\n\n    function getRequestForSegment(mediaInfo, segment) {\n        if (segment === null || segment === undefined) {\n            return null;\n        }\n\n        const request = new FragmentRequest();\n        const representation = segment.representation;\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\n        let url = segment.media;\n\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\n        url = replaceIDForTemplate(url, representation.id);\n        url = unescapeDollarsInTemplate(url);\n\n        request.mediaType = getType();\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\n        request.range = segment.mediaRange;\n        request.startTime = segment.presentationStartTime;\n        request.mediaStartTime = segment.mediaStartTime;\n        request.duration = segment.duration;\n        request.timescale = representation.timescale;\n        request.availabilityStartTime = segment.availabilityStartTime;\n        request.availabilityEndTime = segment.availabilityEndTime;\n        request.wallStartTime = segment.wallStartTime;\n        request.quality = representation.index;\n        request.index = segment.availabilityIdx;\n        request.mediaInfo = mediaInfo;\n        request.adaptationIndex = representation.adaptation.index;\n        request.representationId = representation.id;\n\n        if (setRequestUrl(request, url, representation)) {\n            return request;\n        }\n    }\n\n    function isMediaFinished(representation) {\n        let isFinished = false;\n\n        if (!representation) return isFinished;\n\n        if (!isDynamicManifest) {\n            if (segmentIndex >= representation.availableSegmentsNumber) {\n                isFinished = true;\n            }\n        } else {\n            if (dynamicStreamCompleted) {\n                isFinished = true;\n            } else if (lastSegment) {\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\n                const duration = representation.adaptation.period.duration;\n\n                isFinished = endTime >= duration;\n            }\n        }\n        return isFinished;\n    }\n\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return request;\n        }\n\n        const idx = segmentIndex;\n        const keepIdx = options ? options.keepIdx : false;\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\n\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\n            requestedTime = time;\n            logger.debug('Getting the request for time : ' + time);\n        }\n\n        const segment = segmentsController.getSegmentByTime(representation, time);\n        if (segment) {\n            segmentIndex = segment.availabilityIdx;\n            lastSegment = segment;\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\n            request = getRequestForSegment(mediaInfo, segment);\n        } else {\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = type;\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete in getSegmentRequestForTime');\n            }\n        }\n\n        if (keepIdx && idx >= 0) {\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\n        }\n\n        return request;\n    }\n\n    /**\n     * This function returns the next segment request without modifying any internal variables. Any class (e.g CMCD Model) that needs information about the upcoming request should use this method.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequestIdempotent(mediaInfo, representation) {\n        let request = null;\n        let indexToRequest = segmentIndex + 1;\n        const segment = segmentsController.getSegmentByIndex(\n            representation,\n            indexToRequest,\n            lastSegment ? lastSegment.mediaStartTime : -1\n        );\n        if (!segment) return null;\n        request = getRequestForSegment(mediaInfo, segment);\n        return request;\n    }\n\n    /**\n     * Main function to get the next segment request.\n     * @param {object} mediaInfo\n     * @param {object} representation\n     * @return {FragmentRequest|null}\n     */\n    function getNextSegmentRequest(mediaInfo, representation) {\n        let request = null;\n\n        if (!representation || !representation.segmentInfoType) {\n            return null;\n        }\n\n        requestedTime = null;\n\n        let indexToRequest = segmentIndex + 1;\n\n        logger.debug('Getting the next request at index: ' + indexToRequest);\n        // check that there is a segment in this index\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\n            return null;\n        } else {\n            if (segment) {\n                request = getRequestForSegment(mediaInfo, segment);\n                segmentIndex = segment.availabilityIdx;\n            } else {\n                if (isDynamicManifest) {\n                    segmentIndex = indexToRequest - 1;\n                } else {\n                    segmentIndex = indexToRequest;\n                }\n            }\n        }\n\n        if (segment) {\n            lastSegment = segment;\n        } else {\n            const finished = isMediaFinished(representation, segment);\n            if (finished) {\n                request = new FragmentRequest();\n                request.action = FragmentRequest.ACTION_COMPLETE;\n                request.index = segmentIndex - 1;\n                request.mediaType = getType();\n                request.mediaInfo = mediaInfo;\n                logger.debug('Signal complete');\n            }\n        }\n\n        return request;\n    }\n\n    function isEndlessMedia(representation) {\n        return !isFinite(representation.adaptation.period.duration);\n    }\n\n    function onInitializationLoaded(e) {\n        const representation = e.representation;\n        if (!representation.segments) return;\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onSegmentsLoaded(e) {\n        if (e.error) return;\n\n        const fragments = e.segments;\n        const representation = e.representation;\n        const segments = [];\n        let count = 0;\n\n        let i,\n            len,\n            s,\n            seg;\n\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\n            s = fragments[i];\n\n            seg = getTimeBasedSegment(\n                timelineConverter,\n                isDynamicManifest,\n                representation,\n                s.startTime,\n                s.duration,\n                s.timescale,\n                s.media,\n                s.mediaRange,\n                count);\n\n            if (seg) {\n                segments.push(seg);\n                seg = null;\n                count++;\n            }\n        }\n\n        if (segments.length > 0) {\n            representation.segmentAvailabilityRange = {\n                start: segments[0].presentationStartTime,\n                end: segments[segments.length - 1].presentationStartTime\n            };\n            representation.availableSegmentsNumber = segments.length;\n            representation.segments = segments;\n\n            if (isDynamicManifest) {\n                const lastSegment = segments[segments.length - 1];\n                const liveEdge = lastSegment.presentationStartTime - 8;\n                // the last segment is the Expected, not calculated, live edge.\n                setExpectedLiveEdge(liveEdge);\n            }\n        }\n\n        if (!representation.hasInitialization()) {\n            return;\n        }\n\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED,\n            { representation: representation },\n            { streamId: streamInfo.id, mediaType: type }\n        );\n    }\n\n    function onDynamicToStatic() {\n        logger.debug('Dynamic stream complete');\n        dynamicStreamCompleted = true;\n    }\n\n    instance = {\n        initialize: initialize,\n        getStreamId: getStreamId,\n        getType: getType,\n        getStreamInfo: getStreamInfo,\n        getInitRequest: getInitRequest,\n        getRequestForSegment: getRequestForSegment,\n        getSegmentRequestForTime: getSegmentRequestForTime,\n        getNextSegmentRequest: getNextSegmentRequest,\n        setCurrentIndex: setCurrentIndex,\n        getCurrentIndex: getCurrentIndex,\n        isMediaFinished: isMediaFinished,\n        reset: reset,\n        resetIndex: resetIndex,\n        setMimeType: setMimeType,\n        getNextSegmentRequestIdempotent\n    };\n\n    setup();\n\n    return instance;\n}\n\nDashHandler.__dashjs_factory_name = 'DashHandler';\nexport default FactoryMaker.getClassFactory(DashHandler);\n"]}