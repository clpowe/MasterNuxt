{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpWeightSelector.js"],"names":["LoLpWeightSelector","config","targetLatency","bufferMin","segmentDuration","qoeEvaluator","instance","valueList","weightTypeCount","weightOptions","previousLatency","_setup","_resetInitialSettings","_getPermutations","findWeightVector","neurons","currentLatency","currentBuffer","currentRebuffer","currentThroughput","playbackRate","maxQoE","winnerWeights","winnerBitrate","deltaLatency","Math","abs","forEach","neuron","weightVector","weightsObj","throughput","latency","buffer","switch","downloadTime","bitrate","nextBuffer","getNextBuffer","rebuffer","max","wt","weightedRebuffer","weightedLatency","state","totalQoE","calculateSingleUseQoe","_checkConstraints","nextLatency","list","length","perm","map","val","generate","currLen","len","i","currPerm","shift","k","push","concat","getMinBuffer","getSegmentDuration","getNextBufferWithBitrate","bitrateToDownload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"LoLpWeightSelector.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport FactoryMaker from '../../../../core/FactoryMaker';\n\nfunction LoLpWeightSelector(config) {\n    let targetLatency = config.targetLatency;\n    let bufferMin = config.bufferMin;\n    let segmentDuration = config.segmentDuration;\n    let qoeEvaluator = config.qoeEvaluator;\n    let instance,\n        valueList,\n        weightTypeCount,\n        weightOptions,\n        previousLatency;\n\n    /**\n     *\n     * @private\n     */\n    function _setup() {\n        _resetInitialSettings();\n    }\n\n    /**\n     *\n     * @private\n     */\n    function _resetInitialSettings() {\n        valueList = [0.2, 0.4, 0.6, 0.8, 1];\n        weightTypeCount = 4;\n        weightOptions = _getPermutations(valueList, weightTypeCount);\n        previousLatency = 0;\n    }\n\n    /**\n     * Next, at each segment boundary, ABR to input current neurons and target state (only used in Method II) to find the desired weight vector\n     * @param {array} neurons\n     * @param {number} currentLatency\n     * @param {number} currentBuffer\n     * @param {number} currentRebuffer\n     * @param {number} currentThroughput\n     * @param {number} playbackRate\n     * @return {null}\n     * @private\n     */\n    function findWeightVector(neurons, currentLatency, currentBuffer, currentRebuffer, currentThroughput, playbackRate) {\n        let maxQoE = null;\n        let winnerWeights = null;\n        let winnerBitrate = null;\n        let deltaLatency = Math.abs(currentLatency - previousLatency);\n\n        // For each neuron, m\n        neurons.forEach((neuron) => {\n\n            // For each possible weight vector, z\n            // E.g. For [ throughput, latency, buffer, playbackRate, QoE ]\n            //      Possible weightVector = [ 0.2, 0.4, 0.2, 0, 0.2 ]\n            weightOptions.forEach((weightVector) => {\n\n                // Apply weightVector to neuron, compute utility and determine winnerWeights\n                // Method I: Utility based on QoE given current state\n\n                let weightsObj = {\n                    throughput: weightVector[0],\n                    latency: weightVector[1],\n                    buffer: weightVector[2],\n                    switch: weightVector[3]\n                };\n\n                let downloadTime = (neuron.bitrate * segmentDuration) / currentThroughput;\n                let nextBuffer = getNextBuffer(currentBuffer, downloadTime);\n                let rebuffer = Math.max(0.00001, (downloadTime - nextBuffer));\n                let wt;\n                if (weightsObj.buffer === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.buffer);\n                }\n                let weightedRebuffer = wt * rebuffer;\n\n                if (weightsObj.latency === 0) {\n                    wt = 10;\n                } else {\n                    wt = (1 / weightsObj.latency); // inverse the weight because wt and latency should have positive relationship, i.e., higher latency = higher wt\n                }\n                let weightedLatency = wt * neuron.state.latency;\n\n                let totalQoE = qoeEvaluator.calculateSingleUseQoe(neuron.bitrate, weightedRebuffer, weightedLatency, playbackRate);\n                if ((maxQoE === null || totalQoE > maxQoE) && _checkConstraints(currentLatency, nextBuffer, deltaLatency)) {\n                    maxQoE = totalQoE;\n                    winnerWeights = weightVector;\n                    winnerBitrate = neuron.bitrate;\n                }\n            });\n        });\n\n        // winnerWeights was found, check if constraints are satisfied\n        if (winnerWeights === null && winnerBitrate === null) {\n            winnerWeights = -1;\n        }\n\n        previousLatency = currentLatency;\n        return winnerWeights;\n    }\n\n    /**\n     *\n     * @param {number} nextLatency\n     * @param {number} nextBuffer\n     * @param {number} deltaLatency\n     * @return {boolean}\n     * @private\n     */\n    function _checkConstraints(nextLatency, nextBuffer, deltaLatency) {\n        // A1\n        // disabled till we find a better way of estimating latency\n        // fails for all with current value\n        if (nextLatency > targetLatency + deltaLatency) {\n            return false;\n        }\n\n        return nextBuffer >= bufferMin;\n    }\n\n    /**\n     *\n     * @param {array} list\n     * @param {number} length\n     * @return {*}\n     * @private\n     */\n    function _getPermutations(list, length) {\n        // Copy initial values as arrays\n        let perm = list.map(function (val) {\n            return [val];\n        });\n        // Our permutation generator\n        let generate = function (perm, length, currLen) {\n            // Reached desired length\n            if (currLen === length) {\n                return perm;\n            }\n            // For each existing permutation\n            let len = perm.length;\n            for (let i = 0; i < len; i++) {\n                let currPerm = perm.shift();\n                // Create new permutation\n                for (let k = 0; k < list.length; k++) {\n                    perm.push(currPerm.concat(list[k]));\n                }\n            }\n            // Recurse\n            return generate(perm, length, currLen + 1);\n        };\n        // Start with size 1 because of initial values\n        return generate(perm, length, 1);\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getMinBuffer() {\n        return bufferMin;\n    }\n\n    /**\n     *\n     * @return {number}\n     */\n    function getSegmentDuration() {\n        return segmentDuration;\n    }\n\n    /**\n     *\n     * @param {number} bitrateToDownload\n     * @param {number} currentBuffer\n     * @param {number} currentThroughput\n     * @return {number}\n     */\n    function getNextBufferWithBitrate(bitrateToDownload, currentBuffer, currentThroughput) {\n        let downloadTime = (bitrateToDownload * segmentDuration) / currentThroughput;\n        return getNextBuffer(currentBuffer, downloadTime);\n    }\n\n    /**\n     *\n     * @param {number} currentBuffer\n     * @param {number} downloadTime\n     * @return {number}\n     */\n    function getNextBuffer(currentBuffer, downloadTime) {\n        const segmentDuration = getSegmentDuration();\n        let nextBuffer;\n        if (downloadTime > segmentDuration) {\n            nextBuffer = currentBuffer - segmentDuration;\n        } else {\n            nextBuffer = currentBuffer + segmentDuration - downloadTime;\n        }\n        return nextBuffer;\n    }\n\n    instance = {\n        getMinBuffer,\n        getSegmentDuration,\n        getNextBufferWithBitrate,\n        getNextBuffer,\n        findWeightVector\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLpWeightSelector.__dashjs_factory_name = 'LoLpWeightSelector';\nexport default FactoryMaker.getClassFactory(LoLpWeightSelector);\n"]}