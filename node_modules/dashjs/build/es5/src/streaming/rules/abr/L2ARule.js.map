{"version":3,"sources":["../../../../../../src/streaming/rules/abr/L2ARule.js"],"names":["L2A_STATE_ONE_BITRATE","L2A_STATE_STARTUP","L2A_STATE_STEADY","L2ARule","config","context","dashMetrics","eventBus","getInstance","instance","l2AStateDict","l2AParameterDict","logger","setup","getLogger","_resetInitialSettings","on","Events","PLAYBACK_SEEKING","_onPlaybackSeeking","MEDIA_FRAGMENT_LOADED","_onMediaFragmentLoaded","METRIC_ADDED","_onMetricAdded","QUALITY_CHANGE_REQUESTED","_onQualityChangeRequested","_getInitialL2AState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrates","bitrateList","map","b","bandwidth","state","lastQuality","_initializeL2AParameters","_clearL2AStateOnSeek","type","w","prev_w","Q","segment_request_start_s","segment_download_finish_s","B_target","l2AState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","_getL2AState","mediaType","getMediaType","hasOwnProperty","l2aState","e","chunk","l2AParameters","start","isNaN","duration","quality","_checkNewSegment","metric","MetricsConstants","HTTP_REQUEST","value","HTTPRequest","MEDIA_SEGMENT_TYPE","trace","length","trequest","getTime","_tfinish","L2AState","abrQuality","newQuality","_dotmultiplication","arr1","arr2","sumdot","i","euclideanProjection","arr","m","bget","ii","s","sort","a","tmpsum","tmax","x","Math","max","getMaxIndex","switchRequest","create","horizon","vl","pow","alpha","sqrt","bitrateCount","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","isDynamic","manifestInfo","useL2AABR","bufferLevel","getCurrentBufferLevel","safeThroughput","getSafeAverageThroughput","throughput","getAverageThroughput","react","latency","getAverageLatency","videoModel","getVideoModel","currentPlaybackRate","getPlaybackRate","reason","Constants","AUDIO","setTimeToLoadDelay","l2AParameter","getQualityForBitrate","diff1","throughputMeasureTime","getCurrentHttpRequest","reduce","d","downloadBytes","lastthroughput","round","V","sign","temp","abs","indexOf","min","debug","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"L2ARule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2020, Unified Streaming.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the Learn2Adapt-LowLatency (L2A-LL) bitrate adaptation algorithm, see https://github.com/unifiedstreaming/Learn2Adapt-LowLatency/blob/master/Online_learning_for_bitrate_adaptation_in_low_latency_live_streaming_CR.pdf\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\nimport Constants from '../../constants/Constants';\n\nconst L2A_STATE_ONE_BITRATE = 0; // If there is only one bitrate (or initialization failed), always return NO_CHANGE.\nconst L2A_STATE_STARTUP = 1; // Set placeholder buffer such that we download fragments at most recently measured throughput.\nconst L2A_STATE_STEADY = 2; // Buffer primed, we switch to steady operation.\n\n\nfunction L2ARule(config) {\n    config = config || {};\n    const context = this.context;\n\n    const dashMetrics = config.dashMetrics;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        l2AStateDict,\n        l2AParameterDict,\n        logger;\n\n    /**\n     * Setup function to initialize L2ARule\n     */\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    /**\n     * Sets the initial state of the algorithm. Calls the initialize function for the paramteters.\n     * @param {object} rulesContext\n     * @return {object} initialState\n     * @private\n     */\n    function _getInitialL2AState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map((b) => {\n            return b.bandwidth / 1000;\n        });\n\n        initialState.state = L2A_STATE_STARTUP;\n        initialState.bitrates = bitrates;\n        initialState.lastQuality = 0;\n\n        _initializeL2AParameters(mediaInfo);\n        _clearL2AStateOnSeek(initialState);\n\n        return initialState;\n    }\n\n    /**\n     * Initializes the parameters of the algorithm. This will be done once for each media type.\n     * @param {object} mediaInfo\n     * @private\n     */\n    function _initializeL2AParameters(mediaInfo) {\n\n        if (!mediaInfo || !mediaInfo.type) {\n            return;\n        }\n        l2AParameterDict[mediaInfo.type] = {};\n        l2AParameterDict[mediaInfo.type].w = []; //Vector of probabilities associated with bitrate decisions\n        l2AParameterDict[mediaInfo.type].prev_w = []; //Vector of probabilities associated with bitrate decisions calculated in the previous step\n        l2AParameterDict[mediaInfo.type].Q = 0; //Initialization of Lagrangian multiplier (This keeps track of the buffer displacement)\n        l2AParameterDict[mediaInfo.type].segment_request_start_s = 0;\n        l2AParameterDict[mediaInfo.type].segment_download_finish_s = 0;\n        l2AParameterDict[mediaInfo.type].B_target = 1.5; //Target buffer level\n    }\n\n\n    /**\n     * Clears the state object\n     * @param {object} l2AState\n     * @private\n     */\n    function _clearL2AStateOnSeek(l2AState) {\n        l2AState.placeholderBuffer = 0;\n        l2AState.mostAdvancedSegmentStart = NaN;\n        l2AState.lastSegmentWasReplacement = false;\n        l2AState.lastSegmentStart = NaN;\n        l2AState.lastSegmentDurationS = NaN;\n        l2AState.lastSegmentRequestTimeMs = NaN;\n        l2AState.lastSegmentFinishTimeMs = NaN;\n    }\n\n\n    /**\n     * Returns the state object for a fiven media type. If the state object is not yet defined _getInitialL2AState is called\n     * @param {object} rulesContext\n     * @return {object} l2AState\n     * @private\n     */\n    function _getL2AState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let l2AState = l2AStateDict[mediaType];\n\n        if (!l2AState) {\n            l2AState = _getInitialL2AState(rulesContext);\n            l2AStateDict[mediaType] = l2AState;\n        }\n\n        return l2AState;\n    }\n\n    /**\n     * Event handler for the seeking event.\n     * @private\n     */\n    function _onPlaybackSeeking() {\n        for (const mediaType in l2AStateDict) {\n            if (l2AStateDict.hasOwnProperty(mediaType)) {\n                const l2aState = l2AStateDict[mediaType];\n                if (l2aState.state !== L2A_STATE_ONE_BITRATE) {\n                    l2aState.state = L2A_STATE_STARTUP;\n                    _clearL2AStateOnSeek(l2aState);\n                }\n            }\n        }\n    }\n\n    /**\n     * Event handler for the mediaFragmentLoaded event\n     * @param {object} e\n     * @private\n     */\n    function _onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const l2AState = l2AStateDict[e.chunk.mediaInfo.type];\n            const l2AParameters = l2AParameterDict[e.chunk.mediaInfo.type];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(l2AState.mostAdvancedSegmentStart) || start > l2AState.mostAdvancedSegmentStart) {\n                    l2AState.mostAdvancedSegmentStart = start;\n                    l2AState.lastSegmentWasReplacement = false;\n                } else {\n                    l2AState.lastSegmentWasReplacement = true;\n                }\n\n                l2AState.lastSegmentStart = start;\n                l2AState.lastSegmentDurationS = e.chunk.duration;\n                l2AState.lastQuality = e.chunk.quality;\n\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * Event handler for the metricAdded event\n     * @param {object} e\n     * @private\n     */\n    function _onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const l2AState = l2AStateDict[e.mediaType];\n            const l2AParameters = l2AParameterDict[e.mediaType];\n\n            if (l2AState && l2AState.state !== L2A_STATE_ONE_BITRATE) {\n                l2AState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                l2AState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n                _checkNewSegment(l2AState, l2AParameters);\n            }\n        }\n    }\n\n    /**\n     * When a new metric has been added or a media fragment has been loaded the state is adjusted accordingly\n     * @param {object} L2AState\n     * @param {object} l2AParameters\n     * @private\n     */\n    function _checkNewSegment(L2AState, l2AParameters) {\n        if (!isNaN(L2AState.lastSegmentStart) && !isNaN(L2AState.lastSegmentRequestTimeMs)) {\n            l2AParameters.segment_request_start_s = 0.001 * L2AState.lastSegmentRequestTimeMs;\n            l2AParameters.segment_download_finish_s = 0.001 * L2AState.lastSegmentFinishTimeMs;\n            L2AState.lastSegmentStart = NaN;\n            L2AState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    /**\n     * Event handler for the qualityChangeRequested event\n     * @param {object} e\n     * @private\n     */\n    function _onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e && e.mediaType) {\n            const L2AState = l2AStateDict[e.mediaType];\n            if (L2AState && L2AState.state !== L2A_STATE_ONE_BITRATE) {\n                L2AState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    /**\n     * Dot multiplication of two arrays\n     * @param {array} arr1\n     * @param {array} arr2\n     * @return {number} sumdot\n     * @private\n     */\n\n    function _dotmultiplication(arr1, arr2) {\n        if (arr1.length !== arr2.length) {\n            return -1;\n        }\n        let sumdot = 0;\n        for (let i = 0; i < arr1.length; i++) {\n            sumdot = sumdot + arr1[i] * arr2[i];\n        }\n        return sumdot;\n    }\n\n    /**\n     * Project an n-dim vector y to the simplex Dn\n     * Dn = { x : x n-dim, 1 >= x >= 0, sum(x) = 1}\n     * Algorithm is explained at http://arxiv.org/abs/1101.6081\n     * @param {array} arr\n     * @return {array}\n     */\n    function euclideanProjection(arr) {\n        const m = arr.length;\n        let bget = false;\n        let arr2 = [];\n        for (let ii = 0; ii < m; ++ii) {\n            arr2[ii] = arr[ii];\n        }\n        let s = arr.sort(function (a, b) {\n            return b - a;\n        });\n        let tmpsum = 0;\n        let tmax = 0;\n        let x = [];\n        for (let ii = 0; ii < m - 1; ++ii) {\n            tmpsum = tmpsum + s[ii];\n            tmax = (tmpsum - 1) / (ii + 1);\n            if (tmax >= s[ii + 1]) {\n                bget = true;\n                break;\n            }\n        }\n        if (!bget) {\n            tmax = (tmpsum + s[m - 1] - 1) / m;\n        }\n        for (let ii = 0; ii < m; ++ii) {\n            x[ii] = Math.max(arr2[ii] - tmax, 0);\n        }\n        return x;\n    }\n\n    /**\n     * Returns a switch request object indicating which quality is to be played\n     * @param {object} rulesContext\n     * @return {object}\n     */\n    function getMaxIndex(rulesContext) {\n        const switchRequest = SwitchRequest(context).create();\n        const horizon = 4; // Optimization horizon (The amount of steps required to achieve convergence)\n        const vl = Math.pow(horizon, 0.99);// Cautiousness parameter, used to control aggressiveness of the bitrate decision process.\n        const alpha = Math.max(Math.pow(horizon, 1), vl * Math.sqrt(horizon));// Step size, used for gradient descent exploration granularity\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        const bitrateCount = bitrates.length;\n        const scheduleController = rulesContext.getScheduleController();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useL2AABR = rulesContext.useL2AABR();\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic); // In kbits/s\n        const react = 2; // Reactiveness to volatility (abrupt throughput drops), used to re-calibrate Lagrangian multiplier Q\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        const videoModel = rulesContext.getVideoModel();\n        let quality;\n        let currentPlaybackRate = videoModel.getPlaybackRate();\n\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') ||\n            !rulesContext.hasOwnProperty('getScheduleController') || !rulesContext.hasOwnProperty('getStreamInfo') ||\n            !rulesContext.hasOwnProperty('getAbrController') || !rulesContext.hasOwnProperty('useL2AABR')) {\n            return switchRequest;\n        }\n\n        switchRequest.reason = switchRequest.reason || {};\n\n        if ((!useL2AABR) || (mediaType === Constants.AUDIO)) {// L2A decides bitrate only for video. Audio to be included in decision process in a later stage\n            return switchRequest;\n        }\n\n        scheduleController.setTimeToLoadDelay(0);\n\n        const l2AState = _getL2AState(rulesContext);\n\n        if (l2AState.state === L2A_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            return switchRequest;\n        }\n\n        const l2AParameter = l2AParameterDict[mediaType];\n\n        if (!l2AParameter) {\n            return switchRequest;\n        }\n\n        switchRequest.reason.state = l2AState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) {\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (l2AState.state) {\n            case L2A_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);//During strat-up phase abr.controller is responsible for bitrate decisions.\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n                l2AState.lastQuality = quality;\n\n                if (!isNaN(l2AState.lastSegmentDurationS) && bufferLevel >= l2AParameter.B_target) {\n                    l2AState.state = L2A_STATE_STEADY;\n                    l2AParameter.Q = vl;// Initialization of Q langrangian multiplier\n                    // Update of probability vector w, to be used in main adaptation logic of L2A below (steady state)\n                    for (let i = 0; i < bitrateCount; ++i) {\n                        if (i === l2AState.lastQuality) {\n                            l2AParameter.prev_w[i] = 1;\n                        } else {\n                            l2AParameter.prev_w[i] = 0;\n                        }\n                    }\n                }\n\n                break; // L2A_STATE_STARTUP\n            case L2A_STATE_STEADY:\n                let diff1 = [];//Used to calculate the difference between consecutive decisions (w-w_prev)\n\n                // Manual calculation of latency and throughput during previous request\n                let throughputMeasureTime = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.d, 0);\n                const downloadBytes = dashMetrics.getCurrentHttpRequest(mediaType).trace.reduce((a, b) => a + b.b[0], 0);\n                let lastthroughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\n\n                if (lastthroughput < 1) {\n                    lastthroughput = 1;\n                }//To avoid division with 0 (avoid infinity) in case of an absolute network outage\n\n                let V = l2AState.lastSegmentDurationS;\n                let sign = 1;\n\n                //Main adaptation logic of L2A-LL\n                for (let i = 0; i < bitrateCount; ++i) {\n                    bitrates[i] = bitrates[i] / 1000; // Originally in bps, now in Kbps\n                    if (currentPlaybackRate * bitrates[i] > lastthroughput) {// In this case buffer would deplete, leading to a stall, which increases latency and thus the particular probability of selsection of bitrate[i] should be decreased.\n                        sign = -1;\n                    }\n                    // The objective of L2A is to minimize the overall latency=request-response time + buffer length after download+ potential stalling (if buffer less than chunk downlad time)\n                    l2AParameter.w[i] = l2AParameter.prev_w[i] + sign * (V / (2 * alpha)) * ((l2AParameter.Q + vl) * (currentPlaybackRate * bitrates[i] / lastthroughput));//Lagrangian descent\n                }\n\n                // Apply euclidean projection on w to ensure w expresses a probability distribution\n                l2AParameter.w = euclideanProjection(l2AParameter.w);\n\n                for (let i = 0; i < bitrateCount; ++i) {\n                    diff1[i] = l2AParameter.w[i] - l2AParameter.prev_w[i];\n                    l2AParameter.prev_w[i] = l2AParameter.w[i];\n                }\n\n                // Lagrangian multiplier Q calculation:\n                l2AParameter.Q = Math.max(0, l2AParameter.Q - V + V * currentPlaybackRate * ((_dotmultiplication(bitrates, l2AParameter.prev_w) + _dotmultiplication(bitrates, diff1)) / lastthroughput));\n\n                // Quality is calculated as argmin of the absolute difference between available bitrates (bitrates[i]) and bitrate estimation (dotmultiplication(w,bitrates)).\n                let temp = [];\n                for (let i = 0; i < bitrateCount; ++i) {\n                    temp[i] = Math.abs(bitrates[i] - _dotmultiplication(l2AParameter.w, bitrates));\n                }\n\n                // Quality is calculated based on the probability distribution w (the output of L2A)\n                quality = temp.indexOf(Math.min(...temp));\n\n                // We employ a cautious -stepwise- ascent\n                if (quality > l2AState.lastQuality) {\n                    if (bitrates[l2AState.lastQuality + 1] <= lastthroughput) {\n                        quality = l2AState.lastQuality + 1;\n                    }\n                }\n\n                // Provision against bitrate over-estimation, by re-calibrating the Lagrangian multiplier Q, to be taken into account for the next chunk\n                if (bitrates[quality] >= lastthroughput) {\n                    l2AParameter.Q = react * Math.max(vl, l2AParameter.Q);\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                l2AState.lastQuality = switchRequest.quality;\n                break;\n            default:\n                // should not arrive here, try to recover\n                logger.debug('L2A ABR rule invoked in bad state.');\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = l2AState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                l2AState.state = L2A_STATE_STARTUP;\n                _clearL2AStateOnSeek(l2AState);\n        }\n        return switchRequest;\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        l2AStateDict = {};\n        l2AParameterDict = {};\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, _onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, _onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, _onQualityChangeRequested, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nL2ARule.__dashjs_factory_name = 'L2ARule';\nexport default FactoryMaker.getClassFactory(L2ARule);\n"]}