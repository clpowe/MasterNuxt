{"version":3,"sources":["../../../../../../../src/streaming/rules/abr/lolp/LoLpRule.js"],"names":["DWS_TARGET_LATENCY","DWS_BUFFER_MIN","LoLPRule","config","dashMetrics","context","logger","instance","learningController","qoeEvaluator","_setup","getInstance","getLogger","create","getMaxIndex","rulesContext","switchRequest","mediaType","getMediaInfo","type","abrController","getAbrController","streamInfo","getStreamInfo","currentQuality","getQualityFor","mediaInfo","bufferStateVO","getCurrentBufferState","scheduleController","getScheduleController","currentBufferLevel","getCurrentBufferLevel","isDynamic","manifestInfo","playbackController","getPlaybackController","latency","getCurrentLiveLatency","useLoLPABR","Constants","AUDIO","playbackRate","getPlaybackRate","throughputHistory","getThroughputHistory","throughput","getSafeAverageThroughput","debug","Math","round","isNaN","getAbandonmentStateFor","MetricsConstants","ABANDON_LOAD","bitrateList","segmentDuration","getRepresentationInfo","fragmentDuration","minBitrateKbps","bandwidth","maxBitrateKbps","length","i","b","currentBitrate","currentBitrateKbps","httpRequest","getCurrentHttpRequest","lastFragmentDownloadTime","tresponse","getTime","trequest","segmentRebufferTime","setupPerSegmentQoe","logSegmentMetrics","dynamicWeightsSelector","targetLatency","bufferMin","quality","getNextQuality","reason","priority","SwitchRequest","PRIORITY","STRONG","setTimeToLoadDelay","console","log","e","_resetInitialSettings","reset","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"LoLpRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * Authors:\n * Abdelhak Bentaleb | National University of Singapore | bentaleb@comp.nus.edu.sg\n * Mehmet N. Akcay | Ozyegin University | necmettin.akcay@ozu.edu.tr\n * May Lim | National University of Singapore | maylim@comp.nus.edu.sg\n */\n\nimport Debug from '../../../../core/Debug';\nimport FactoryMaker from '../../../../core/FactoryMaker';\nimport LearningAbrController from './LearningAbrController';\nimport LoLpQoeEvaluator from './LoLpQoEEvaluator';\nimport SwitchRequest from '../../SwitchRequest';\nimport MetricsConstants from '../../../constants/MetricsConstants';\nimport LoLpWeightSelector from './LoLpWeightSelector';\nimport Constants from '../../../constants/Constants';\n\nconst DWS_TARGET_LATENCY = 1.5;\nconst DWS_BUFFER_MIN = 0.3;\n\nfunction LoLPRule(config) {\n\n    config = config || {};\n\n    let dashMetrics = config.dashMetrics;\n    let context = this.context;\n\n    let logger,\n        instance,\n        learningController,\n        qoeEvaluator;\n\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        learningController = LearningAbrController(context).create();\n        qoeEvaluator = LoLpQoeEvaluator(context).create();\n    }\n\n    function getMaxIndex(rulesContext) {\n        try {\n            let switchRequest = SwitchRequest(context).create();\n            let mediaType = rulesContext.getMediaInfo().type;\n            let abrController = rulesContext.getAbrController();\n            const streamInfo = rulesContext.getStreamInfo();\n            let currentQuality = abrController.getQualityFor(mediaType, streamInfo);\n            const mediaInfo = rulesContext.getMediaInfo();\n            const bufferStateVO = dashMetrics.getCurrentBufferState(mediaType);\n            const scheduleController = rulesContext.getScheduleController();\n            const currentBufferLevel = dashMetrics.getCurrentBufferLevel(mediaType, true);\n            const isDynamic = streamInfo && streamInfo.manifestInfo ? streamInfo.manifestInfo.isDynamic : null;\n            const playbackController = scheduleController.getPlaybackController();\n            let latency = playbackController.getCurrentLiveLatency();\n\n            if (!rulesContext.useLoLPABR() || (mediaType === Constants.AUDIO)) {\n                return switchRequest;\n            }\n\n            if (!latency) {\n                latency = 0;\n            }\n\n            const playbackRate = playbackController.getPlaybackRate();\n            const throughputHistory = abrController.getThroughputHistory();\n            const throughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n            logger.debug(`Throughput ${Math.round(throughput)} kbps`);\n\n            if (isNaN(throughput) || !bufferStateVO) {\n                return switchRequest;\n            }\n\n            if (abrController.getAbandonmentStateFor(mediaType) === MetricsConstants.ABANDON_LOAD) {\n                return switchRequest;\n            }\n\n            // QoE parameters\n            let bitrateList = mediaInfo.bitrateList;  // [{bandwidth: 200000, width: 640, height: 360}, ...]\n            let segmentDuration = rulesContext.getRepresentationInfo().fragmentDuration;\n            let minBitrateKbps = bitrateList[0].bandwidth / 1000.0;                         // min bitrate level\n            let maxBitrateKbps = bitrateList[bitrateList.length - 1].bandwidth / 1000.0;    // max bitrate level\n            for (let i = 0; i < bitrateList.length; i++) {  // in case bitrateList is not sorted as expected\n                let b = bitrateList[i].bandwidth / 1000.0;\n                if (b > maxBitrateKbps)\n                    maxBitrateKbps = b;\n                else if (b < minBitrateKbps) {\n                    minBitrateKbps = b;\n                }\n            }\n\n            // Learning rule pre-calculations\n            let currentBitrate = bitrateList[currentQuality].bandwidth;\n            let currentBitrateKbps = currentBitrate / 1000.0;\n            let httpRequest = dashMetrics.getCurrentHttpRequest(mediaType, true);\n            let lastFragmentDownloadTime = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) / 1000;\n            let segmentRebufferTime = lastFragmentDownloadTime > segmentDuration ? lastFragmentDownloadTime - segmentDuration : 0;\n            qoeEvaluator.setupPerSegmentQoe(segmentDuration, maxBitrateKbps, minBitrateKbps);\n            qoeEvaluator.logSegmentMetrics(currentBitrateKbps, segmentRebufferTime, latency, playbackRate);\n\n            /*\n            * Dynamic Weights Selector (step 1/2: initialization)\n            */\n            let dynamicWeightsSelector = LoLpWeightSelector(context).create({\n                targetLatency: DWS_TARGET_LATENCY,\n                bufferMin: DWS_BUFFER_MIN,\n                segmentDuration,\n                qoeEvaluator\n            });\n\n            /*\n             * Select next quality\n             */\n            switchRequest.quality = learningController.getNextQuality(mediaInfo, throughput * 1000, latency, currentBufferLevel, playbackRate, currentQuality, dynamicWeightsSelector);\n            switchRequest.reason = { throughput: throughput, latency: latency };\n            switchRequest.priority = SwitchRequest.PRIORITY.STRONG;\n\n            scheduleController.setTimeToLoadDelay(0);\n\n            if (switchRequest.quality !== currentQuality) {\n                console.log('[TgcLearningRule][' + mediaType + '] requesting switch to index: ', switchRequest.quality, 'Average throughput', Math.round(throughput), 'kbps');\n            }\n\n            return switchRequest;\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Reset objects to their initial state\n     * @private\n     */\n    function _resetInitialSettings() {\n        learningController.reset();\n        qoeEvaluator.reset();\n    }\n\n    /**\n     * Reset the rule\n     */\n    function reset() {\n        _resetInitialSettings();\n    }\n\n    instance = {\n        getMaxIndex,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nLoLPRule.__dashjs_factory_name = 'LoLPRule';\nexport default FactoryMaker.getClassFactory(LoLPRule);\n"]}