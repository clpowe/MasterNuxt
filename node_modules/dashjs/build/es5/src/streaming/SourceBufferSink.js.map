{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":["MAX_ALLOWED_DISCONTINUITY","SourceBufferSink","mediaSource","mediaInfo","onAppendedCallback","oldBuffer","context","eventBus","getInstance","instance","type","logger","buffer","isAppendingInProgress","intervalId","callbacks","appendQueue","onAppended","setup","getLogger","codec","match","Error","addSourceBuffer","changeType","debug","updateAppendWindow","CHECK_INTERVAL","addEventListener","updateEndHandler","errHandler","err","setInterval","checkIsUpdateEnded","ex","isText","indexOf","textController","getTextSourceBuffer","getType","reset","keepBuffer","removeEventListener","clearInterval","getClassName","removeSourceBuffer","e","error","getBuffer","getAllBufferRanges","buffered","message","hasDiscontinuitiesAfter","time","ranges","length","i","len","start","end","append","chunk","DashJSError","Errors","APPEND_ERROR_CODE","APPEND_ERROR_MESSAGE","push","waitForUpdateEnd","appendNextInQueue","bind","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","sInfo","appendWindowEnd","duration","appendWindowStart","isFinite","warn","remove","forceRemoval","sourceBufferSink","readyState","trigger","Events","SOURCEBUFFER_REMOVE_COMPLETED","from","to","unintended","code","nextChunk","splice","oldRanges","afterSuccess","newRanges","checkBufferGapsAfterAppend","call","bytes","appendBuffer","fatal","isChunkAlignedWithRange","Math","round","abort","setTextTrack","executeCallback","cb","shift","updating","callback","__dashjs_factory_name","factory","FactoryMaker","getClassFactory"],"mappings":"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","file":"SourceBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\nimport Errors from '../core/errors/Errors';\n\nconst MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\n\n/**\n * @class SourceBufferSink\n * @ignore\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        type,\n        logger,\n        buffer,\n        isAppendingInProgress,\n        intervalId;\n\n    let callbacks = [];\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        isAppendingInProgress = false;\n\n        type = mediaInfo.type;\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\n            if (buffer.changeType && oldBuffer) {\n                logger.debug('Doing period transition with changeType');\n                buffer.changeType(codec);\n            }\n\n            updateAppendWindow();\n\n            const CHECK_INTERVAL = 50;\n            // use updateend event if possible\n            if (typeof buffer.addEventListener === 'function') {\n                try {\n                    buffer.addEventListener('updateend', updateEndHandler, false);\n                    buffer.addEventListener('error', errHandler, false);\n                    buffer.addEventListener('abort', errHandler, false);\n\n                } catch (err) {\n                    // use setInterval to periodically check if updating has been completed\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n                }\n            } else {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function getType() {\n        return type;\n    }\n\n    function reset(keepBuffer) {\n        if (buffer) {\n            if (typeof buffer.removeEventListener === 'function') {\n                buffer.removeEventListener('updateend', updateEndHandler, false);\n                buffer.removeEventListener('error', errHandler, false);\n                buffer.removeEventListener('abort', errHandler, false);\n            }\n            clearInterval(intervalId);\n            callbacks = [];\n            if (!keepBuffer) {\n                try {\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\n                        logger.debug(`Removing sourcebuffer from media source`);\n                        mediaSource.removeSourceBuffer(buffer);\n                    }\n                } catch (e) {\n                    logger.error('Failed to remove source buffer from media source.');\n                }\n                buffer = null;\n            }\n            isAppendingInProgress = false;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        try {\n            return buffer.buffered;\n        } catch (e) {\n            logger.error('getAllBufferRanges exception: ' + e.message);\n            return null;\n        }\n    }\n\n    function hasDiscontinuitiesAfter(time) {\n        try {\n            const ranges = getAllBufferRanges();\n            if (ranges && ranges.length > 1) {\n                for (let i = 0, len = ranges.length; i < len; i++) {\n                    if (i > 0) {\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        } catch (e) {\n            logger.error('hasDiscontinuities exception: ' + e.message);\n        }\n        return false;\n    }\n\n    function append(chunk) {\n        if (!chunk) {\n            onAppended({\n                chunk: chunk,\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\n            });\n            return;\n        }\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(appendNextInQueue.bind(this));\n        }\n    }\n\n    function updateTimestampOffset(MSETimeOffset) {\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\n            waitForUpdateEnd(() => {\n                if (MSETimeOffset < 0) {\n                    MSETimeOffset += 0.001;\n                }\n                buffer.timestampOffset = MSETimeOffset;\n            });\n        }\n    }\n\n    function updateAppendWindow(sInfo) {\n        if (!buffer) {\n            return;\n        }\n        waitForUpdateEnd(() => {\n            try {\n                let appendWindowEnd = mediaSource.duration;\n                let appendWindowStart = 0;\n                if (sInfo && !isNaN(sInfo.start) && !isNaN(sInfo.duration) && isFinite(sInfo.duration)) {\n                    appendWindowEnd = sInfo.start + sInfo.duration;\n                }\n                if (sInfo && !isNaN(sInfo.start)) {\n                    appendWindowStart = sInfo.start;\n                }\n                buffer.appendWindowStart = 0;\n                buffer.appendWindowEnd = appendWindowEnd;\n                buffer.appendWindowStart = appendWindowStart;\n                logger.debug(`Updated append window. Set start to ${buffer.appendWindowStart} and end to ${buffer.appendWindowEnd}`);\n            } catch (e) {\n                logger.warn(`Failed to set append window`);\n            }\n        });\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end,\n                        unintended: false\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    unintended: false,\n                    error: new DashJSError(err.code, err.message)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        const sourceBufferSink = this;\n\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0, 1);\n            let oldRanges = [];\n            const afterSuccess = function () {\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\n                const newRanges = getAllBufferRanges();\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (nextChunk.bytes.length === 0) {\n                    afterSuccess.call(this);\n                } else {\n                    oldRanges = getAllBufferRanges();\n                    if (buffer.appendBuffer) {\n                        buffer.appendBuffer(nextChunk.bytes);\n                    } else {\n                        buffer.append(nextChunk.bytes, nextChunk);\n                    }\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                    waitForUpdateEnd(afterSuccess.bind(this));\n                }\n            } catch (err) {\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message)\n                    });\n                }\n            }\n        }\n    }\n\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\n            isChunkAlignedWithRange(oldRanges, chunk)) {\n            // A split in the range was created while appending\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                buffer: buffer,\n                from: newRanges.end(newRanges.length - 2),\n                to: newRanges.start(newRanges.length - 1),\n                unintended: true\n            });\n        }\n    }\n\n    function isChunkAlignedWithRange(oldRanges, chunk) {\n        for (let i = 0; i < oldRanges.length; i++) {\n            const start = Math.round(oldRanges.start(i));\n            const end = Math.round(oldRanges.end(i));\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n        appendQueue = [];\n    }\n\n    function executeCallback() {\n        if (callbacks.length > 0) {\n            const cb = callbacks.shift();\n            if (buffer.updating) {\n                waitForUpdateEnd(cb);\n            } else {\n                cb();\n                // Try to execute next callback if still not updating\n                executeCallback();\n            }\n        }\n    }\n\n    function checkIsUpdateEnded() {\n        // if updating is still in progress do nothing and wait for the next check again.\n        if (buffer.updating) return;\n        // updating is completed, now we can stop checking and resolve the promise\n        executeCallback();\n    }\n\n    function updateEndHandler() {\n        if (buffer.updating) return;\n\n        executeCallback();\n    }\n\n    function errHandler() {\n        logger.error('SourceBufferSink error');\n    }\n\n    function waitForUpdateEnd(callback) {\n        callbacks.push(callback);\n\n        if (!buffer.updating) {\n            executeCallback();\n        }\n    }\n\n    instance = {\n        getType: getType,\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset,\n        updateTimestampOffset: updateTimestampOffset,\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter,\n        waitForUpdateEnd: waitForUpdateEnd,\n        updateAppendWindow\n    };\n\n    setup();\n\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]}