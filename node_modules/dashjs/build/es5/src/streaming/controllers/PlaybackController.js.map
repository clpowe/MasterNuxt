{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","dashMetrics","adapter","videoModel","timelineConverter","streamSwitch","streamSeekTime","wallclockTimeIntervalId","liveDelay","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","seekTarget","internalSeek","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","settings","setup","getLogger","reset","initialize","sInfo","periodSwitch","seekTime","addAllListeners","manifestInfo","ua","navigator","userAgent","toLowerCase","isSafari","test","on","Events","STREAM_INITIALIZED","onStreamInitialized","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","priority","EventBus","EVENT_PRIORITY_HIGH","STREAM_INITIALIZING","onStreamInitializing","play","e","isNaN","startTime","liveStartTime","dvrInfo","getCurrentDVRInfo","dvrWindow","range","startTimeFromUri","getStartTimeFromUriParameters","info","Math","max","min","start","duration","getTime","trigger","PLAYBACK_SEEKING","seek","getTimeToStreamEnd","parseFloat","getStreamEndTime","toFixed","getElement","isPaused","pause","isSeeking","time","stickToBuffered","internal","currentTime","PLAYBACK_SEEK_ASKED","setCurrentTime","seekToLive","DVRMetrics","DVRWindow","end","getLiveDelay","getNormalizedTime","t","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","computeAndSetLiveDelay","fragmentDuration","dvrWindowSize","minBufferTime","delay","ret","END_OF_PLAYLIST_PADDING","MIN_BUFFER_TIME_FACTOR","FRAGMENT_DURATION_FACTOR","adjustedFragmentDuration","isFinite","NaN","suggestedPresentationDelay","getSuggestedPresentationDelay","get","streaming","lowLatencyEnabled","liveDelayFragmentCount","useSuggestedPresentationDelay","getAvailabilityStartTime","targetDelayCapping","setLiveDelay","value","useMaxValue","getCurrentLiveLatency","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","fragData","getURIFragmentData","refStream","getStreams","refStreamStartTime","getStreamInfo","split","posix","indexOf","substring","parseInt","getActualPresentationTime","mediatype","actualTime","debug","abs","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","wallclockTimeUpdateInterval","clearInterval","updateCurrentTime","mediaType","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","id","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","onPlaybackSeeking","onPlaybackSeeked","PLAYBACK_SEEKED","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","_isCatchupEnabled","liveCatchup","_needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","enabled","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","bl","p","_getCatchupMode","playbackBufferMin","mode","Constants","LIVE_CATCHUP_MODE_LOLP","LIVE_CATCHUP_MODE_DEFAULT","catchupMode","currentLiveLatency","liveCatchupLatencyThreshold","getLiveCatchupLatencyThreshold","liveCatchUpMinDrift","minDrift","currentBuffer","_lolpNeedToCatchUpCustom","_defaultNeedToCatchUp","latencyDrift","results","currentPlaybackRate","liveCatchupPlaybackRate","_calculateNewPlaybackRateLolP","_calculateNewPlaybackRateDefault","newRate","setPlaybackRate","deltaLatency","maxDrift","liveCatchUpPlaybackRate","cpr","d","s","pow","E","deltaBuffer","minDifference","stream","request","minDelay","warn","update","streamId","state","MetricsConstants","BUFFER_EMPTY","setStallState","onPlaybackStalled","PLAYBACK_STALLED","applyServiceDescription","serviceDescriptions","llsd","i","length","sd","schemeIdUri","SERVICE_DESCRIPTION_LL_SCHEME","supplementalProperties","SUPPLEMENTAL_PROPERTY_LL_SCHEME","latency","undefined","addEventListener","removeEventListener","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"PlaybackController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport MetricsConstants from '../constants/MetricsConstants';\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\n\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\n\nfunction PlaybackController() {\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        streamController,\n        dashMetrics,\n        adapter,\n        videoModel,\n        timelineConverter,\n        streamSwitch,\n        streamSeekTime,\n        wallclockTimeIntervalId,\n        liveDelay,\n        streamInfo,\n        isDynamic,\n        mediaPlayerModel,\n        playOnceInitialized,\n        lastLivePlaybackTime,\n        availabilityStartTime,\n        seekTarget,\n        internalSeek,\n        isLowLatencySeekingInProgress,\n        playbackStalled,\n        minPlaybackRateChange,\n        uriFragmentModel,\n        settings;\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function initialize(sInfo, periodSwitch, seekTime) {\n        streamInfo = sInfo;\n        addAllListeners();\n        isDynamic = streamInfo.manifestInfo.isDynamic;\n        isLowLatencySeekingInProgress = false;\n        playbackStalled = false;\n        streamSwitch = periodSwitch === true;\n        streamSeekTime = seekTime;\n        internalSeek = false;\n\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\n\n        // Detect safari browser (special behavior for low latency streams)\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\n\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this, { priority: EventBus.EVENT_PRIORITY_HIGH });\n        eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n\n        if (playOnceInitialized) {\n            playOnceInitialized = false;\n            play();\n        }\n    }\n\n    function onStreamInitialized(e) {\n        // Seamless period switch\n        if (streamSwitch && isNaN(streamSeekTime)) return;\n\n        // Seek new stream in priority order:\n        // - at seek time (streamSeekTime) when switching period\n        // - at start time provided in URI parameters\n        // - at stream/period start time (for static streams) or live start time (for dynamic streams)\n        let startTime = streamSeekTime;\n        if (isNaN(startTime)) {\n            if (isDynamic) {\n                // For dynamic stream, start by default at (live edge - live delay)\n                startTime = e.liveStartTime;\n                // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\n                const dvrInfo = dashMetrics.getCurrentDVRInfo();\n                const dvrWindow = dvrInfo ? dvrInfo.range : null;\n                if (dvrWindow) {\n                    // #t shall be relative to period start\n                    const startTimeFromUri = getStartTimeFromUriParameters(true);\n                    if (!isNaN(startTimeFromUri)) {\n                        logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                        startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\n                    }\n                }\n            } else {\n                // For static stream, start by default at period start\n                startTime = streamInfo.start;\n                // If start time in URI, take max value between period start and time from URI (if in period range)\n                const startTimeFromUri = getStartTimeFromUriParameters(false);\n                if (!isNaN(startTimeFromUri) && startTimeFromUri < (startTime + streamInfo.duration)) {\n                    logger.info('Start time from URI parameters: ' + startTimeFromUri);\n                    startTime = Math.max(startTime, startTimeFromUri);\n                }\n            }\n        }\n\n        if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\n            // Trigger PLAYBACK_SEEKING event for controllers\n            eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: startTime });\n            // Seek video model\n            seek(startTime, false, true);\n        }\n    }\n\n    function getTimeToStreamEnd() {\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\n    }\n\n    function getStreamEndTime() {\n        return streamInfo.start + streamInfo.duration;\n    }\n\n    function play() {\n        if (streamInfo && videoModel && videoModel.getElement()) {\n            videoModel.play();\n        } else {\n            playOnceInitialized = true;\n        }\n    }\n\n    function isPaused() {\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\n    }\n\n    function pause() {\n        if (streamInfo && videoModel) {\n            videoModel.pause();\n        }\n    }\n\n    function isSeeking() {\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\n    }\n\n    function seek(time, stickToBuffered, internal) {\n        if (!streamInfo || !videoModel) return;\n\n        let currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\n        if (time === currentTime) return;\n\n        internalSeek = (internal === true);\n\n        if (!internalSeek) {\n            seekTarget = time;\n            eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\n        }\n        logger.info('Requesting seek to time: ' + time + (internalSeek ? ' (internal)' : ''));\n        videoModel.setCurrentTime(time, stickToBuffered);\n    }\n\n    function seekToLive() {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\n    }\n\n    function getTime() {\n        return streamInfo && videoModel ? videoModel.getTime() : null;\n    }\n\n    function getNormalizedTime() {\n        let t = getTime();\n\n        if (isDynamic && !isNaN(availabilityStartTime)) {\n            const timeOffset = availabilityStartTime / 1000;\n            // Fix current time for firefox and safari (returned as an absolute time)\n            if (t > timeOffset) {\n                t -= timeOffset;\n            }\n        }\n        return t;\n    }\n\n    function getPlaybackRate() {\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\n    }\n\n    function getPlayedRanges() {\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\n    }\n\n    function getEnded() {\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\n    }\n\n    function getIsDynamic() {\n        return isDynamic;\n    }\n\n    function getStreamController() {\n        return streamController;\n    }\n\n    /**\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\n     * @param {number} fragmentDuration - seconds?\n     * @param {number} dvrWindowSize - seconds?\n     * @param {number} minBufferTime - seconds?\n     * @returns {number} object\n     * @memberof PlaybackController#\n     */\n    function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\n        let delay,\n            ret,\n            startTime;\n        const END_OF_PLAYLIST_PADDING = 10;\n        const MIN_BUFFER_TIME_FACTOR = 4;\n        const FRAGMENT_DURATION_FACTOR = 4;\n        const adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\n\n        let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\n\n        if (settings.get().streaming.lowLatencyEnabled) {\n            delay = 0;\n        } else if (mediaPlayerModel.getLiveDelay()) {\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\n        } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\n        } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\n            delay = suggestedPresentationDelay;\n        } else if (!isNaN(adjustedFragmentDuration)) {\n            delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\n        } else {\n            delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\n        }\n\n        startTime = adapter.getAvailabilityStartTime();\n\n        if (startTime !== null) {\n            availabilityStartTime = startTime;\n        }\n\n        if (dvrWindowSize > 0) {\n            // cap target latency to:\n            // - dvrWindowSize / 2 for short playlists\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\n            ret = Math.min(delay, targetDelayCapping);\n        } else {\n            ret = delay;\n        }\n        liveDelay = ret;\n        return ret;\n    }\n\n    function getLiveDelay() {\n        return liveDelay;\n    }\n\n    function setLiveDelay(value, useMaxValue = false) {\n        if (useMaxValue && value < liveDelay) {\n            return;\n        }\n\n        liveDelay = value;\n    }\n\n    function getCurrentLiveLatency() {\n        if (!isDynamic || isNaN(availabilityStartTime)) {\n            return NaN;\n        }\n        let currentTime = getNormalizedTime();\n        if (isNaN(currentTime) || currentTime === 0) {\n            return 0;\n        }\n\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\n    }\n\n    function reset() {\n        playOnceInitialized = false;\n        streamSwitch = false;\n        streamSeekTime = NaN;\n        liveDelay = 0;\n        availabilityStartTime = 0;\n        seekTarget = NaN;\n        if (videoModel) {\n            eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\n            eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this);\n            stopUpdatingWallclockTime();\n            removeAllListeners();\n        }\n        wallclockTimeIntervalId = null;\n        videoModel = null;\n        streamInfo = null;\n        isDynamic = null;\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n        if (config.mediaPlayerModel) {\n            mediaPlayerModel = config.mediaPlayerModel;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.uriFragmentModel) {\n            uriFragmentModel = config.uriFragmentModel;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n    }\n\n    function getStartTimeFromUriParameters(isDynamic) {\n        const fragData = uriFragmentModel.getURIFragmentData();\n        if (!fragData || !fragData.t) {\n            return NaN;\n        }\n        const refStream = streamController.getStreams()[0];\n        const refStreamStartTime = refStream.getStreamInfo().start;\n        // Consider only start time of MediaRange\n        // TODO: consider end time of MediaRange to stop playback at provided end time\n        fragData.t = fragData.t.split(',')[0];\n        // \"t=<time>\" : time is relative to 1st period start\n        // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\n        const posix = fragData.t.indexOf('posix:') !== -1 ? fragData.t.substring(6) === 'now' ? Date.now() / 1000 : parseInt(fragData.t.substring(6)) : NaN;\n        let startTime = (isDynamic && !isNaN(posix)) ? posix - availabilityStartTime / 1000 : parseInt(fragData.t) + refStreamStartTime;\n        return startTime;\n    }\n\n    function getActualPresentationTime(currentTime, mediatype) {\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(mediatype);\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\n        let actualTime;\n\n        if (!DVRWindow) {\n            return NaN;\n        }\n\n        logger.debug(`Checking DVR window for at ${currentTime} with DVR window range ${DVRWindow.start} - ${DVRWindow.end}`);\n        if (currentTime > DVRWindow.end) {\n            actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\n\n        } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\n\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\n            // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\n            // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\n            //actualTime = DVRWindow.start;\n            actualTime = DVRWindow.start;\n        } else {\n            actualTime = currentTime;\n        }\n\n        return actualTime;\n    }\n\n    function startUpdatingWallclockTime() {\n        if (wallclockTimeIntervalId !== null) return;\n\n        const tick = function () {\n            onWallclockTime();\n        };\n\n        wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\n    }\n\n    function stopUpdatingWallclockTime() {\n        clearInterval(wallclockTimeIntervalId);\n        wallclockTimeIntervalId = null;\n    }\n\n    function updateCurrentTime(mediaType) {\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\n        const currentTime = getNormalizedTime();\n        const actualTime = getActualPresentationTime(currentTime, mediaType);\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\n        if (timeChanged && !isSeeking()) {\n            logger.debug(`UpdateCurrentTime: Seek to actual time: ${actualTime} from currentTime: ${currentTime}`);\n            seek(actualTime);\n        }\n    }\n\n    function onDataUpdateCompleted(e) {\n        if (e.error) return;\n\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\n        const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\n\n        if (info === null || streamInfo.id !== info.id) return;\n        streamInfo = info;\n\n        updateCurrentTime();\n    }\n\n    function onCanPlay() {\n        eventBus.trigger(Events.CAN_PLAY);\n    }\n\n    function onPlaybackStart() {\n        logger.info('Native video element event: play');\n        updateCurrentTime();\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() });\n    }\n\n    function onPlaybackWaiting() {\n        logger.info('Native video element event: waiting');\n        eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPlaying() {\n        logger.info('Native video element event: playing');\n        eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() });\n    }\n\n    function onPlaybackPaused() {\n        logger.info('Native video element event: pause');\n        eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() });\n    }\n\n    function onPlaybackSeeking() {\n        // Check if internal seeking to be ignored\n        if (internalSeek) {\n            internalSeek = false;\n            return;\n        }\n\n        let seekTime = getTime();\n        // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\n        // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\n        if (!isNaN(seekTarget) && seekTarget !== seekTime) {\n            seekTime = seekTarget;\n        }\n        seekTarget = NaN;\n\n        logger.info('Seeking to: ' + seekTime);\n        startUpdatingWallclockTime();\n        eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime });\n    }\n\n    function onPlaybackSeeked() {\n        logger.info('Native video element event: seeked');\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\n    }\n\n    function onPlaybackTimeUpdated() {\n        if (streamInfo) {\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\n                timeToEnd: getTimeToStreamEnd(),\n                time: getTime()\n            });\n        }\n    }\n\n    function updateLivePlaybackTime() {\n        const now = Date.now();\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\n            lastLivePlaybackTime = now;\n            onPlaybackTimeUpdated();\n        }\n    }\n\n    function onPlaybackProgress() {\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\n    }\n\n    function onPlaybackRateChanged() {\n        const rate = getPlaybackRate();\n        logger.info('Native video element event: ratechange: ', rate);\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate });\n    }\n\n    function onPlaybackMetaDataLoaded() {\n        logger.info('Native video element event: loadedmetadata');\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\n        startUpdatingWallclockTime();\n    }\n\n    // Event to handle the native video element ended event\n    function onNativePlaybackEnded() {\n        logger.info('Native video element event: ended');\n        pause();\n        stopUpdatingWallclockTime();\n        const streamInfo = streamController ? streamController.getActiveStreamInfo() : null;\n        if (!streamInfo) return;\n        eventBus.trigger(Events.PLAYBACK_ENDED, { 'isLast': streamInfo.isLast });\n    }\n\n    // Handle DASH PLAYBACK_ENDED event\n    function onPlaybackEnded(e) {\n        if (wallclockTimeIntervalId && e.isLast) {\n            // PLAYBACK_ENDED was triggered elsewhere, react.\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\n            const seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\n            videoModel.setCurrentTime(seekTime);\n            pause();\n            stopUpdatingWallclockTime();\n        }\n    }\n\n    function onPlaybackError(event) {\n        const target = event.target || event.srcElement;\n        eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error });\n    }\n\n    function onWallclockTime() {\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\n            isDynamic: isDynamic,\n            time: new Date()\n        });\n\n        // Updates playback time for paused dynamic streams\n        // (video element doesn't call timeupdate when the playback is paused)\n        if (getIsDynamic() && isPaused()) {\n            updateLivePlaybackTime();\n        }\n    }\n\n    function onPlaybackProgression() {\n        if (\n            isDynamic &&\n            _isCatchupEnabled() &&\n            settings.get().streaming.liveCatchup.playbackRate > 0 &&\n            !isPaused() &&\n            !isSeeking()\n        ) {\n            if (_needToCatchUp()) {\n                startPlaybackCatchUp();\n            } else {\n                stopPlaybackCatchUp();\n            }\n        }\n    }\n\n    function _isCatchupEnabled() {\n        return settings.get().streaming.liveCatchup.enabled || settings.get().streaming.lowLatencyEnabled;\n    }\n\n    function getBufferLevel() {\n        let bufferLevel = null;\n        streamController.getActiveStreamProcessors().forEach(p => {\n            const bl = p.getBufferLevel();\n            if (bufferLevel === null) {\n                bufferLevel = bl;\n            } else {\n                bufferLevel = Math.min(bufferLevel, bl);\n            }\n        });\n\n        return bufferLevel;\n    }\n\n    /**\n     * Returns the mode for live playback catchup.\n     * @return {String}\n     * @private\n     */\n    function _getCatchupMode() {\n        const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n        return settings.get().streaming.liveCatchup.mode === Constants.LIVE_CATCHUP_MODE_LOLP && playbackBufferMin !== null && !isNaN(playbackBufferMin) ? Constants.LIVE_CATCHUP_MODE_LOLP : Constants.LIVE_CATCHUP_MODE_DEFAULT;\n    }\n\n    /**\n     * Checks whether the catchup mechanism should be enabled\n     * @return {boolean}\n     */\n    function _needToCatchUp() {\n        try {\n            if (_isCatchupEnabled() && settings.get().streaming.liveCatchup.playbackRate > 0 && getTime() > 0) {\n\n                const catchupMode = _getCatchupMode();\n                const currentLiveLatency = getCurrentLiveLatency();\n                const liveDelay = mediaPlayerModel.getLiveDelay();\n                const liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n\n                if (catchupMode === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                    const currentBuffer = getBufferLevel();\n                    const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n\n                    return _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, liveCatchUpMinDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold);\n                } else {\n                    return _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, liveCatchUpMinDrift);\n                }\n            }\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Default algorithm to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} liveCatchupLatencyThreshold\n     * @param {number} minDrift\n     * @return {boolean}\n     * @private\n     */\n    function _defaultNeedToCatchUp(currentLiveLatency, liveDelay, liveCatchupLatencyThreshold, minDrift) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return latencyDrift > minDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * LoL+ logic to determine if catchup mode should be enabled\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} currentBuffer\n     * @param {number} playbackBufferMin\n     * @param {number} liveCatchupLatencyThreshold\n     * @return {boolean}\n     * @private\n     */\n    function _lolpNeedToCatchUpCustom(currentLiveLatency, liveDelay, minDrift, currentBuffer, playbackBufferMin, liveCatchupLatencyThreshold) {\n        try {\n            const latencyDrift = Math.abs(currentLiveLatency - liveDelay);\n\n            return (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold) && (latencyDrift > minDrift || currentBuffer < playbackBufferMin);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Apply catchup mode\n     */\n    function startPlaybackCatchUp() {\n        if (videoModel) {\n            let results;\n            const currentPlaybackRate = videoModel.getPlaybackRate();\n            const liveCatchupPlaybackRate = settings.get().streaming.liveCatchup.playbackRate;\n            const currentLiveLatency = getCurrentLiveLatency();\n            const liveDelay = mediaPlayerModel.getLiveDelay();\n            const bufferLevel = getBufferLevel();\n            // Custom playback control: Based on buffer level\n            if (_getCatchupMode() === Constants.LIVE_CATCHUP_MODE_LOLP) {\n                const liveCatchUpMinDrift = settings.get().streaming.liveCatchup.minDrift;\n                const playbackBufferMin = settings.get().streaming.liveCatchup.playbackBufferMin;\n                results = _calculateNewPlaybackRateLolP(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, liveCatchUpMinDrift, playbackBufferMin, bufferLevel, currentPlaybackRate);\n            } else {\n                // Default playback control: Based on target and current latency\n                results = _calculateNewPlaybackRateDefault(liveCatchupPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate);\n            }\n\n            // Obtain newRate and apply to video model\n            let newRate = results.newRate;\n            if (newRate) {  // non-null\n                videoModel.setPlaybackRate(newRate);\n            }\n\n            const deltaLatency = currentLiveLatency - liveDelay;\n            if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress &&\n                deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\n                isLowLatencySeekingInProgress = true;\n                seekToLive();\n            } else {\n                isLowLatencySeekingInProgress = false;\n            }\n        }\n    }\n\n    /**\n     * Default algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateDefault(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        const deltaLatency = currentLiveLatency - liveDelay;\n        const d = deltaLatency * 5;\n\n        // Playback rate must be between (1 - cpr) - (1 + cpr)\n        // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n        const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n        let newRate = (1 - cpr) + s;\n        // take into account situations in which there are buffer stalls,\n        // in which increasing playbackRate to reach target latency will\n        // just cause more and more stall situations\n        if (playbackStalled) {\n            // const bufferLevel = getBufferLevel();\n            if (bufferLevel > liveDelay / 2) {\n                // playbackStalled = false;\n                playbackStalled = false;\n            } else if (deltaLatency > 0) {\n                newRate = 1.0;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n\n    }\n\n    /**\n     * Lol+ algorithm to calculate the new playback rate\n     * @param {number} liveCatchUpPlaybackRate\n     * @param {number} currentLiveLatency\n     * @param {number} liveDelay\n     * @param {number} minDrift\n     * @param {number} playbackBufferMin\n     * @param {number} bufferLevel\n     * @param {number} currentPlaybackRate\n     * @return {{newRate: number}}\n     * @private\n     */\n    function _calculateNewPlaybackRateLolP(liveCatchUpPlaybackRate, currentLiveLatency, liveDelay, minDrift, playbackBufferMin, bufferLevel, currentPlaybackRate) {\n        const cpr = liveCatchUpPlaybackRate;\n        let newRate;\n\n        // Hybrid: Buffer-based\n        if (bufferLevel < playbackBufferMin) {\n            // Buffer in danger, slow down\n            const deltaBuffer = bufferLevel - playbackBufferMin;  // -ve value\n            const d = deltaBuffer * 5;\n\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n            newRate = (1 - cpr) + s;\n\n            logger.debug('[LoL+ playback control_buffer-based] bufferLevel: ' + bufferLevel + ', newRate: ' + newRate);\n        } else {\n            // Hybrid: Latency-based\n            // Buffer is safe, vary playback rate based on latency\n\n            // Check if latency is within range of target latency\n            const minDifference = 0.02;\n            if (Math.abs(currentLiveLatency - liveDelay) <= (minDifference * liveDelay)) {\n                newRate = 1;\n            } else {\n                const deltaLatency = currentLiveLatency - liveDelay;\n                const d = deltaLatency * 5;\n\n                // Playback rate must be between (1 - cpr) - (1 + cpr)\n                // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\n                const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\n                newRate = (1 - cpr) + s;\n            }\n\n            logger.debug('[LoL+ playback control_latency-based] latency: ' + currentLiveLatency + ', newRate: ' + newRate);\n        }\n\n        if (playbackStalled) {\n            if (bufferLevel > liveDelay / 2) {\n                playbackStalled = false;\n            }\n        }\n\n        // don't change playbackrate for small variations (don't overload element with playbackrate changes)\n        if (Math.abs(currentPlaybackRate - newRate) <= minPlaybackRateChange) {\n            newRate = null;\n        }\n\n        return {\n            newRate: newRate\n        };\n    }\n\n    function stopPlaybackCatchUp() {\n        if (videoModel) {\n            videoModel.setPlaybackRate(1.0);\n        }\n    }\n\n    function onFragmentLoadProgress(e) {\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\n        if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\n            const minDelay = 1.2 * e.request.duration;\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\n                const s = { streaming: { liveDelay: minDelay } };\n                settings.update(s);\n            }\n        }\n    }\n\n    function onBufferLevelStateChanged(e) {\n        // do not stall playback when get an event from Stream that is not active\n        if (e.streamId !== streamInfo.id) return;\n\n        if (_isCatchupEnabled()) {\n            if (e.state === MetricsConstants.BUFFER_EMPTY && !isSeeking()) {\n                if (!playbackStalled) {\n                    playbackStalled = true;\n                    stopPlaybackCatchUp();\n                }\n            }\n        } else {\n            videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY);\n        }\n    }\n\n    function onPlaybackStalled(e) {\n        eventBus.trigger(Events.PLAYBACK_STALLED, { e: e });\n    }\n\n    function onStreamInitializing(e) {\n        applyServiceDescription(e.streamInfo, e.mediaInfo);\n    }\n\n    function applyServiceDescription(streamInfo, mediaInfo) {\n        if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\n            // is there a service description for low latency defined?\n            let llsd;\n\n            for (let i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\n                const sd = streamInfo.manifestInfo.serviceDescriptions[i];\n                if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) {\n                    llsd = sd;\n                    break;\n                }\n            }\n\n            if (llsd) {\n                if (mediaInfo && mediaInfo.supplementalProperties &&\n                    mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\n                    if (llsd.latency && llsd.latency.target > 0) {\n                        logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveDelay: llsd.latency.target / 1000,\n                                liveCatchup: {\n                                    minDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\n                                }\n                            }\n                        });\n                    }\n                    if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\n                        logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\n                        settings.update({\n                            streaming: {\n                                lowLatencyEnabled: true,\n                                liveCatchup: {\n                                    playbackRate: llsd.playbackRate.max - 1.0\n                                }\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    function addAllListeners() {\n        videoModel.addEventListener('canplay', onCanPlay);\n        videoModel.addEventListener('play', onPlaybackStart);\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\n        videoModel.addEventListener('playing', onPlaybackPlaying);\n        videoModel.addEventListener('pause', onPlaybackPaused);\n        videoModel.addEventListener('error', onPlaybackError);\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.addEventListener('progress', onPlaybackProgress);\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.addEventListener('stalled', onPlaybackStalled);\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\n    }\n\n    function removeAllListeners() {\n        videoModel.removeEventListener('canplay', onCanPlay);\n        videoModel.removeEventListener('play', onPlaybackStart);\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\n        videoModel.removeEventListener('pause', onPlaybackPaused);\n        videoModel.removeEventListener('error', onPlaybackError);\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\n        videoModel.removeEventListener('progress', onPlaybackProgress);\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\n        getTimeToStreamEnd: getTimeToStreamEnd,\n        getTime: getTime,\n        getNormalizedTime: getNormalizedTime,\n        getPlaybackRate: getPlaybackRate,\n        getPlayedRanges: getPlayedRanges,\n        getEnded: getEnded,\n        getIsDynamic: getIsDynamic,\n        getStreamController: getStreamController,\n        computeAndSetLiveDelay: computeAndSetLiveDelay,\n        getLiveDelay: getLiveDelay,\n        setLiveDelay: setLiveDelay,\n        getCurrentLiveLatency: getCurrentLiveLatency,\n        play: play,\n        isPaused: isPaused,\n        pause: pause,\n        isSeeking: isSeeking,\n        getStreamEndTime,\n        seek: seek,\n        updateCurrentTime: updateCurrentTime,\n        reset: reset\n    };\n\n    setup();\n\n    return instance;\n}\n\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\n"]}