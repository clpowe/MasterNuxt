{"version":3,"sources":["../../../../../src/streaming/controllers/EventController.js"],"names":["EventController","MPD_RELOAD_SCHEME","MPD_RELOAD_VALUE","MPD_CALLBACK_SCHEME","MPD_CALLBACK_VALUE","REMAINING_EVENTS_THRESHOLD","EVENT_HANDLED_STATES","DISCARDED","UPDATED","ADDED","context","eventBus","getInstance","instance","logger","inlineEvents","inbandEvents","eventInterval","lastEventTimerCall","manifestUpdater","playbackController","settings","eventHandlingInProgress","isStarted","_setup","getLogger","_resetInitialSettings","checkConfig","Error","Date","now","_stop","clearInterval","_onStopEventController","e","start","debug","refreshDelay","get","streaming","eventControllerRefreshDelay","isNaN","setInterval","_onEventTimer","addInlineEvents","values","i","length","event","result","_addOrUpdateEvent","id","_startEvent","MediaPlayerEvents","EVENT_MODE_ON_RECEIVE","addInbandEvents","eventStream","schemeIdUri","undefined","_handleManifestReloadEvent","value","events","shouldOverwriteExistingEvents","eventState","indexOfExistingEvent","findIndex","push","validUntil","calculatedPresentationTime","newDuration","NaN","duration","trigger","MANIFEST_VALIDITY_CHANGED","newManifestValidAfter","mode","EVENT_MODE_ON_START","currentVideoTime","getTime","presentationTimeThreshold","Math","max","_triggerEvents","_triggerRemainingEvents","callback","_eventHasExpired","_eventIsInvalid","_removeEvent","_iterateAndTriggerCallback","currentTime","periodDuration","period","periodStart","calculatedPresentationTimeInSeconds","abs","schemeIdUris","Object","keys","schemeIdEvents","forEach","threshold","periodEndTime","eventId","presentationTimeDelta","_refreshManifest","_sendCallbackRequest","messageData","filter","refreshManifest","url","loader","create","load","method","request","responseType","setConfig","config","getInlineEvents","getInbandEvents","reset","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"EventController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport EventBus from '../../core/EventBus';\nimport MediaPlayerEvents from '../../streaming/MediaPlayerEvents';\nimport XHRLoader from '../net/XHRLoader';\n\nfunction EventController() {\n\n    const MPD_RELOAD_SCHEME = 'urn:mpeg:dash:event:2012';\n    const MPD_RELOAD_VALUE = 1;\n\n    const MPD_CALLBACK_SCHEME = 'urn:mpeg:dash:event:callback:2015';\n    const MPD_CALLBACK_VALUE = 1;\n\n    const REMAINING_EVENTS_THRESHOLD = 300;\n\n    const EVENT_HANDLED_STATES = {\n        DISCARDED: 'discarded',\n        UPDATED: 'updated',\n        ADDED: 'added'\n    };\n\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        logger,\n        inlineEvents, // Holds all Inline Events not triggered yet\n        inbandEvents, // Holds all Inband Events not triggered yet\n        eventInterval, // variable holding the setInterval\n        lastEventTimerCall,\n        manifestUpdater,\n        playbackController,\n        settings,\n        eventHandlingInProgress,\n        isStarted;\n\n    /**\n     * Internal setup when class is instanced\n     */\n    function _setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n        _resetInitialSettings();\n    }\n\n    /**\n     * Checks if the provded configuration is valid\n     */\n    function checkConfig() {\n        if (!manifestUpdater || !playbackController) {\n            throw new Error('setConfig function has to be called previously');\n        }\n    }\n\n    /**\n     * Reset to initial settings\n     */\n    function _resetInitialSettings() {\n        isStarted = false;\n        inlineEvents = {}; // Format inlineEvents[schemeIdUri]\n        inbandEvents = {}; // Format inlineEvents[schemeIdUri]\n        eventInterval = null;\n        eventHandlingInProgress = false;\n        lastEventTimerCall = Date.now() / 1000;\n    }\n\n    /**\n     * Stops the EventController by clearing the event interval\n     */\n    function _stop() {\n        try {\n            if (eventInterval !== null && isStarted) {\n                clearInterval(eventInterval);\n                eventInterval = null;\n                isStarted = false;\n                _onStopEventController();\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Starts the interval function of the EventController\n     */\n    function start() {\n        try {\n            checkConfig();\n            logger.debug('Start Event Controller');\n            const refreshDelay = settings.get().streaming.eventControllerRefreshDelay;\n            if (!isStarted && !isNaN(refreshDelay)) {\n                isStarted = true;\n                eventInterval = setInterval(_onEventTimer, refreshDelay);\n            }\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add MPD events to the list of events.\n     * Events that are not in the MPD anymore but not triggered yet will still be deleted.\n     * Existing events might get updated.\n     * @param {Array.<Object>} values\n     */\n    function addInlineEvents(values) {\n        try {\n            checkConfig();\n\n            if (values) {\n                for (let i = 0; i < values.length; i++) {\n                    let event = values[i];\n                    let result = _addOrUpdateEvent(event, inlineEvents, true);\n\n                    if (result === EVENT_HANDLED_STATES.ADDED) {\n                        logger.debug(`Added inline event with id ${event.id}`);\n                        // If we see the event for the first time we trigger it in onReceive mode\n                        _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                    } else if (result === EVENT_HANDLED_STATES.UPDATED) {\n                        logger.debug(`Updated inline event with id ${event.id}`);\n                    }\n                }\n            }\n            logger.debug(`Added ${values.length} inline events`);\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Add EMSG events to the list of events\n     * Messages with the same id within the scope of the same scheme_id_uri and value pair are equivalent , i.e. processing of any one event message box with the same id is sufficient.\n     * @param {Array.<Object>} values\n     */\n    function addInbandEvents(values) {\n        try {\n            checkConfig();\n\n            for (let i = 0; i < values.length; i++) {\n                let event = values[i];\n                let result = _addOrUpdateEvent(event, inbandEvents, false);\n\n                if (result === EVENT_HANDLED_STATES.ADDED) {\n                    if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && inbandEvents[event.id] === undefined) {\n                        _handleManifestReloadEvent(event);\n                    }\n                    logger.debug('Added inband event with id ' + event.id);\n                    _startEvent(event, values, MediaPlayerEvents.EVENT_MODE_ON_RECEIVE);\n                } else {\n                    logger.debug(`Inband event with scheme_id_uri ${event.eventStream.schemeIdUri}, value ${event.eventStream.value} and id ${event.id} was ignored because it has been added before.`);\n                }\n            }\n            _onEventTimer();\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Adds or updates an event to/in the list of events\n     * @param {object} event\n     * @param {object} events\n     * @param {boolean} shouldOverwriteExistingEvents\n     * @return {string}\n     * @private\n     */\n    function _addOrUpdateEvent(event, events, shouldOverwriteExistingEvents = false) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n        let eventState = EVENT_HANDLED_STATES.DISCARDED;\n\n        if (!events[schemeIdUri]) {\n            events[schemeIdUri] = [];\n        }\n\n        const indexOfExistingEvent = events[schemeIdUri].findIndex((e) => {\n            return ((!value || (e.eventStream.value && e.eventStream.value === value)) && (e.id === id));\n        });\n\n        if (indexOfExistingEvent === -1) {\n            events[schemeIdUri].push(event);\n            eventState = EVENT_HANDLED_STATES.ADDED;\n        } else if (shouldOverwriteExistingEvents) {\n            events[schemeIdUri][indexOfExistingEvent] = event;\n            eventState = EVENT_HANDLED_STATES.UPDATED;\n        }\n\n        return eventState;\n    }\n\n    /**\n     * Triggers an MPD reload\n     * @param {object} event\n     * @private\n     */\n    function _handleManifestReloadEvent(event) {\n        try {\n            if (event.eventStream.value == MPD_RELOAD_VALUE) {\n                const validUntil = event.calculatedPresentationTime;\n                let newDuration;\n                if (event.calculatedPresentationTime == 0xFFFFFFFF) {//0xFF... means remaining duration unknown\n                    newDuration = NaN;\n                } else {\n                    newDuration = event.calculatedPresentationTime + event.duration;\n                }\n                //logger.info('Manifest validity changed: Valid until: ' + validUntil + '; remaining duration: ' + newDuration);\n                eventBus.trigger(MediaPlayerEvents.MANIFEST_VALIDITY_CHANGED, {\n                    id: event.id,\n                    validUntil: validUntil,\n                    newDuration: newDuration,\n                    newManifestValidAfter: NaN //event.message_data - this is an arraybuffer with a timestring in it, but not used yet\n                }, {\n                    mode: MediaPlayerEvents.EVENT_MODE_ON_START\n                });\n            }\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Iterate through the eventList and trigger the events\n     */\n    function _onEventTimer() {\n        try {\n            if (!eventHandlingInProgress) {\n                eventHandlingInProgress = true;\n                const currentVideoTime = playbackController.getTime();\n                let presentationTimeThreshold = (currentVideoTime - lastEventTimerCall);\n\n                // For dynamic streams lastEventTimeCall will be large in the first iteration. Avoid firing all events at once.\n                presentationTimeThreshold = lastEventTimerCall > 0 ? Math.max(0, presentationTimeThreshold) : 0;\n\n                _triggerEvents(inbandEvents, presentationTimeThreshold, currentVideoTime);\n                _triggerEvents(inlineEvents, presentationTimeThreshold, currentVideoTime);\n\n                lastEventTimerCall = currentVideoTime;\n                eventHandlingInProgress = false;\n            }\n        } catch (e) {\n            eventHandlingInProgress = false;\n        }\n    }\n\n    /**\n     * When the EventController is stopped this callback is triggered. Starts the remaining events.\n     * @private\n     */\n    function _onStopEventController() {\n        try {\n            // EventController might be stopped before the period is over. Before we stop the event controller we check for events that needs to be triggered at the period boundary.\n            _triggerRemainingEvents(inbandEvents);\n            _triggerRemainingEvents(inlineEvents);\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterate over a list of events and trigger the ones for which the presentation time is within the current timing interval\n     * @param {object} events\n     * @param {number} presentationTimeThreshold\n     * @param {number} currentVideoTime\n     * @private\n     */\n    function _triggerEvents(events, presentationTimeThreshold, currentVideoTime) {\n        try {\n            const callback = function (event) {\n                if (event !== undefined) {\n                    const duration = !isNaN(event.duration) ? event.duration : 0;\n                    // The event is either about to start or has already been started and we are within its duration\n                    if ((event.calculatedPresentationTime <= currentVideoTime && event.calculatedPresentationTime + presentationTimeThreshold + duration >= currentVideoTime)) {\n                        _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                    } else if (_eventHasExpired(currentVideoTime, duration + presentationTimeThreshold, event.calculatedPresentationTime) || _eventIsInvalid(event)) {\n                        logger.debug(`Deleting event ${event.id} as it is expired or invalid`);\n                        _removeEvent(events, event);\n                    }\n                }\n            };\n\n            _iterateAndTriggerCallback(events, callback);\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Triggers the remaining events after the EventController has been stopped\n     * @param {object} events\n     * @private\n     */\n    function _triggerRemainingEvents(events) {\n        try {\n            const currentTime = playbackController.getTime();\n            const callback = function (event) {\n                const periodDuration = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.duration) ? event.eventStream.period.duration : NaN;\n                const periodStart = event.eventStream && event.eventStream.period && !isNaN(event.eventStream.period.start) ? event.eventStream.period.start : NaN;\n\n                if (isNaN(periodDuration) || isNaN(periodStart)) {\n                    return;\n                }\n\n                const calculatedPresentationTimeInSeconds = event.calculatedPresentationTime;\n\n                if (Math.abs(calculatedPresentationTimeInSeconds - currentTime) < REMAINING_EVENTS_THRESHOLD) {\n                    _startEvent(event, events, MediaPlayerEvents.EVENT_MODE_ON_START);\n                }\n\n            };\n\n            _iterateAndTriggerCallback(events, callback());\n\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Iterates over the inline/inband event object and triggers a callback for each event\n     * @param {object} events\n     * @param {function} callback\n     * @private\n     */\n    function _iterateAndTriggerCallback(events, callback) {\n        try {\n            if (events) {\n                const schemeIdUris = Object.keys(events);\n                for (let i = 0; i < schemeIdUris.length; i++) {\n                    const schemeIdEvents = events[schemeIdUris[i]];\n                    schemeIdEvents.forEach((event) => {\n                        if (event !== undefined) {\n                            callback(event);\n                        }\n                    });\n                }\n            }\n        } catch (e) {\n\n        }\n    }\n\n    /**\n     * Checks if an event is expired. For instance if the presentationTime + the duration of an event are smaller than the current video time.\n     * @param {number} currentVideoTime\n     * @param {number} threshold\n     * @param {number} calculatedPresentationTimeInSeconds\n     * @return {boolean}\n     * @private\n     */\n    function _eventHasExpired(currentVideoTime, threshold, calculatedPresentationTimeInSeconds) {\n        try {\n            return currentVideoTime - threshold > calculatedPresentationTimeInSeconds;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Checks if an event is invalid. This is the case if the end time of the parent period is smaller than the presentation time of the event.\n     * @param {object} event\n     * @return {boolean}\n     * @private\n     */\n    function _eventIsInvalid(event) {\n        try {\n            const periodEndTime = event.eventStream.period.start + event.eventStream.period.duration;\n\n            return event.calculatedPresentationTime > periodEndTime;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Starts an event. Depending on the schemeIdUri we distinguis between\n     * - MPD Reload events\n     * - MPD Callback events\n     * - Events to be dispatched to the application\n     * Events should be removed from the list before beeing triggered. Otherwise the event handler might cause an error and the remove function will not be called.\n     * @param {object} event\n     * @param {object} events\n     * @param {String} mode\n     * @private\n     */\n    function _startEvent(event, events, mode) {\n        try {\n            const currentVideoTime = playbackController.getTime();\n            const eventId = event.id;\n\n            if (mode === MediaPlayerEvents.EVENT_MODE_ON_RECEIVE) {\n                logger.debug(`Received event ${eventId}`);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n                return;\n            }\n\n            if (event.eventStream.schemeIdUri === MPD_RELOAD_SCHEME && event.eventStream.value === MPD_RELOAD_VALUE) {\n                if (event.duration !== 0 || event.presentationTimeDelta !== 0) { //If both are set to zero, it indicates the media is over at this point. Don't reload the manifest.\n                    logger.debug(`Starting manifest refresh event ${eventId} at ${currentVideoTime}`);\n                    _removeEvent(events, event);\n                    _refreshManifest();\n                }\n            } else if (event.eventStream.schemeIdUri === MPD_CALLBACK_SCHEME && event.eventStream.value === MPD_CALLBACK_VALUE) {\n                logger.debug(`Starting callback event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                _sendCallbackRequest(event.messageData);\n            } else {\n                logger.debug(`Starting event ${eventId} at ${currentVideoTime}`);\n                _removeEvent(events, event);\n                eventBus.trigger(event.eventStream.schemeIdUri, { event: event }, { mode });\n            }\n\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Removes an event from the list. If this is the last event of type \"schemeIdUri\"  the corresponding schemeIdUri Object in the list of events is deleted.\n     * @param {object} events\n     * @param {object} event\n     * @private\n     */\n    function _removeEvent(events, event) {\n        const schemeIdUri = event.eventStream.schemeIdUri;\n        const value = event.eventStream.value;\n        const id = event.id;\n\n        events[schemeIdUri] = events[schemeIdUri].filter((e) => {\n            return (value && e.eventStream.value && e.eventStream.value !== value) || (e.id !== id);\n        });\n\n        if (events[schemeIdUri].length === 0) {\n            delete events[schemeIdUri];\n        }\n\n    }\n\n    /**\n     * Refresh the manifest\n     * @private\n     */\n    function _refreshManifest() {\n        try {\n            checkConfig();\n            manifestUpdater.refreshManifest();\n        } catch (e) {\n        }\n    }\n\n    /**\n     * Send a callback request\n     * @param {String} url\n     * @private\n     */\n    function _sendCallbackRequest(url) {\n        try {\n            let loader = XHRLoader(context).create({});\n            loader.load({\n                method: 'get',\n                url: url,\n                request: {\n                    responseType: 'arraybuffer'\n                }\n            });\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Set the config of the EventController\n     * @param {object} config\n     */\n    function setConfig(config) {\n        try {\n            if (!config) {\n                return;\n            }\n            if (config.manifestUpdater) {\n                manifestUpdater = config.manifestUpdater;\n            }\n            if (config.playbackController) {\n                playbackController = config.playbackController;\n            }\n            if (config.settings) {\n                settings = config.settings;\n            }\n\n        } catch (e) {\n            throw e;\n        }\n    }\n\n    /**\n     * Returns all inline events that have not been triggered yet\n     * @return {object}\n     */\n    function getInlineEvents() {\n        return inlineEvents;\n    }\n\n    /**\n     * Returns all inband events that have not been triggered yet\n     * @return {object}\n     */\n    function getInbandEvents() {\n        return inbandEvents;\n    }\n\n    /**\n     * Stop the EventController and reset all initial settings\n     */\n    function reset() {\n        _stop();\n        _resetInitialSettings();\n    }\n\n    instance = {\n        addInlineEvents,\n        addInbandEvents,\n        getInbandEvents,\n        getInlineEvents,\n        start,\n        setConfig,\n        reset\n    };\n\n    _setup();\n\n    return instance;\n}\n\nEventController.__dashjs_factory_name = 'EventController';\nexport default FactoryMaker.getSingletonFactory(EventController);\n"]}