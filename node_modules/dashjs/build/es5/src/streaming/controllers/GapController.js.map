{"version":3,"sources":["../../../../../src/streaming/controllers/GapController.js"],"names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","GapController","context","eventBus","getInstance","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","timelineConverter","adapter","jumpTimeoutHandler","logger","initialize","registerEvents","setup","getLogger","reset","stopGapHandler","unregisterEvents","resetInitialSettings","NaN","setConfig","config","on","Events","WALLCLOCK_TIME_UPDATED","_onWallclockTimeUpdated","PLAYBACK_SEEKING","_onPlaybackSeeking","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","off","startGapHandler","clearTimeout","_shouldCheckForGaps","currentTime","getTime","jumpGap","get","streaming","jumpGaps","getActiveStreamProcessors","length","isSeeking","hasStreamFinishedBuffering","getActiveStream","isPaused","getIsStreamSwitchInProgress","getHasMediaOrIntialisationError","getNextRangeIndex","ranges","nextRangeIndex","j","isNaN","rangeEnd","end","start","e","debug","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","getBufferRange","seekToPosition","jumpToStreamEnd","gap","timeToStreamEnd","getTimeToStreamEnd","isFinite","parseFloat","getStreamEndTime","toFixed","timeUntilGapEnd","warn","trigger","GAP_CAUSED_SEEK_TO_PERIOD_END","seekTime","duration","isDynamic","getIsDynamic","timeToWait","window","setTimeout","seek","GAP_CAUSED_INTERNAL_SEEK","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"sEA8BA,qD,yDACA,uC,2CACA,gD,6CACA,6C,oIAjCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmCA,GAAMA,sBAAuB,GAA7B,CACA,GAAMC,qBAAsB,EAA5B,CACA,GAAMC,eAAgB,GAAtB,CAEA,QAASC,cAAT,EAAyB,CACrB,GAAMC,SAAU,KAAKA,OAArB,CACA,GAAMC,UAAW,uBAASD,OAAT,EAAkBE,WAAlB,EAAjB,CAEA,GAAIC,gBAAJ,CACIC,uBADJ,CAEIC,eAFJ,CAGIC,sBAHJ,CAIIC,yBAJJ,CAKIC,0BALJ,CAMIC,yBANJ,CAOIC,uBAPJ,CAQIC,iBARJ,CASIC,wBATJ,CAUIC,cAVJ,CAWIC,yBAXJ,CAYIC,aAZJ,CAcA,QAASC,WAAT,EAAsB,CAClBC,iBACH,CAED,QAASC,MAAT,EAAiB,CACbH,OAAS,oBAAMf,OAAN,EAAeE,WAAf,GAA6BiB,SAA7B,CAAuChB,QAAvC,CAAT,CAEAiB,QACH,CAED,QAASA,MAAT,EAAiB,CACbC,iBACAC,mBACAC,uBACH,CAED,QAASA,qBAAT,EAAgC,CAC5BhB,mBAAqB,IAArB,CACAC,oBAAsBgB,GAAtB,CACAlB,gBAAkB,CAAlB,CACAQ,mBAAqB,IAArB,CACH,CAED,QAASW,UAAT,CAAmBC,MAAnB,CAA2B,CACvB,GAAI,CAACA,MAAL,CAAa,CACT,OACH,CACD,GAAIA,OAAOrB,QAAX,CAAqB,CACjBA,SAAWqB,OAAOrB,QAAlB,CACH,CACD,GAAIqB,OAAOjB,kBAAX,CAA+B,CAC3BA,mBAAqBiB,OAAOjB,kBAA5B,CACH,CACD,GAAIiB,OAAOhB,gBAAX,CAA6B,CACzBA,iBAAmBgB,OAAOhB,gBAA1B,CACH,CACD,GAAIgB,OAAOf,UAAX,CAAuB,CACnBA,WAAae,OAAOf,UAApB,CACH,CACD,GAAIe,OAAOd,iBAAX,CAA8B,CAC1BA,kBAAoBc,OAAOd,iBAA3B,CACH,CACD,GAAIc,OAAOb,OAAX,CAAoB,CAChBA,QAAUa,OAAOb,OAAjB,CACH,CACJ,CAED,QAASI,eAAT,EAA0B,CACtBhB,SAAS0B,EAAT,CAAYC,iBAAOC,sBAAnB,CAA2CC,uBAA3C,CAAoE,IAApE,EACA7B,SAAS0B,EAAT,CAAYC,iBAAOG,gBAAnB,CAAqCC,kBAArC,CAAyD,IAAzD,EACA/B,SAAS0B,EAAT,CAAYC,iBAAOK,2BAAnB,CAAgDC,eAAhD,CAAiE/B,QAAjE,EACH,CAED,QAASmB,iBAAT,EAA4B,CACxBrB,SAASkC,GAAT,CAAaP,iBAAOC,sBAApB,CAA4CC,uBAA5C,CAAqE,IAArE,EACA7B,SAASkC,GAAT,CAAaP,iBAAOG,gBAApB,CAAsCC,kBAAtC,CAA0D,IAA1D,EACA/B,SAASkC,GAAT,CAAaP,iBAAOK,2BAApB,CAAiDC,eAAjD,CAAkE/B,QAAlE,EACH,CAED,QAAS+B,gBAAT,EAA2B,CACvB,GAAI,CAAC3B,kBAAL,CAAyB,CACrB6B,kBACH,CACJ,CAED,QAASJ,mBAAT,EAA8B,CAC1B,GAAIlB,kBAAJ,CAAwB,CACpBuB,aAAavB,kBAAb,EACAA,mBAAqB,IAArB,CACH,CACJ,CAED,QAASgB,wBAAT,EAAiC,KAAO,CACpC,GAAI,CAACQ,qBAAL,CAA4B,CACxB,OACH,CAEDhC,kBACA,GAAIA,iBAAmBT,mBAAvB,CAA4C,CACxC,GAAM0C,aAAc9B,mBAAmB+B,OAAnB,EAApB,CACA,GAAIpC,mBAAqBmC,WAAzB,CAAsC,CAClCE,QAAQF,WAAR,CAAqB,IAArB,EACH,CAFD,IAEO,CACHnC,iBAAmBmC,WAAnB,CACA/B,oBAAsBgB,GAAtB,CACH,CACDlB,gBAAkB,CAAlB,CACH,CACJ,CAED,QAASgC,oBAAT,EAA+B,CAC3B,MAAOjC,UAASqC,GAAT,GAAeC,SAAf,CAAyBC,QAAzB,EAAqClC,iBAAiBmC,yBAAjB,GAA6CC,MAA7C,CAAsD,CAA3F,GACF,CAACrC,mBAAmBsC,SAAnB,EAAD,EAAmCrC,iBAAiBsC,0BAAjB,CAA4CtC,iBAAiBuC,eAAjB,EAA5C,CADjC,GACqH,CAACxC,mBAAmByC,QAAnB,EADtH,EACuJ,CAACxC,iBAAiByC,2BAAjB,EADxJ,EAEH,CAACzC,iBAAiB0C,+BAAjB,EAFL,CAGH,CAED,QAASC,kBAAT,CAA2BC,MAA3B,CAAmCf,WAAnC,CAAgD,CAC5C,GAAI,CAEA,GAAI,CAACe,MAAD,EAAYA,OAAOR,MAAP,EAAiB,CAAjB,EAAsBP,YAAc,CAApD,CAAwD,CACpD,MAAOf,IAAP,CACH,CACD,GAAI+B,gBAAiB/B,GAArB,CACA,GAAIgC,GAAI,CAAR,CAEA,MAAOC,MAAMF,cAAN,GAAyBC,EAAIF,OAAOR,MAA3C,CAAmD,CAC/C,GAAMY,UAAWF,EAAI,CAAJ,CAAQF,OAAOK,GAAP,CAAWH,EAAI,CAAf,CAAR,CAA4B,CAA7C,CACA,GAAIjB,YAAce,OAAOM,KAAP,CAAaJ,CAAb,CAAd,EAAiCE,SAAWnB,WAAX,CAAyBzC,aAA9D,CAA6E,CACzEyD,eAAiBC,CAAjB,CACH,CACDA,GAAK,CAAL,CACH,CACD,MAAOD,eAAP,CAEH,CAAC,MAAOM,CAAP,CAAU,CACR,MAAO,KAAP,CACH,CACJ,CAGD,QAASzB,gBAAT,EAA2B,CACvB,GAAI,CACA,GAAI,CAAC7B,kBAAL,CAAyB,CACrBQ,OAAO+C,KAAP,CAAa,6BAAb,EACAvD,mBAAqBwD,YAAY,UAAM,CACnC,GAAI,CAACzB,qBAAL,CAA4B,CACxB,OACH,CACD,GAAMC,aAAc9B,mBAAmB+B,OAAnB,EAApB,CACAC,QAAQF,WAAR,EAEH,CAPoB,CAOlB3C,oBAPkB,CAArB,CAQH,CACJ,CAAC,MAAOiE,CAAP,CAAU,CACX,CACJ,CAED,QAASxC,eAAT,EAA0B,CACtBN,OAAO+C,KAAP,CAAa,6BAAb,EACA,GAAIvD,kBAAJ,CAAwB,CACpByD,cAAczD,kBAAd,EACAA,mBAAqB,IAArB,CACH,CACJ,CAED,QAASkC,QAAT,CAAiBF,WAAjB,CAAuD,IAAzB0B,gBAAyB,2DAAP,KAAO,CACnD,GAAMC,eAAgB7D,SAASqC,GAAT,GAAeC,SAAf,CAAyBuB,aAA/C,CACA,GAAMC,eAAgB9D,SAASqC,GAAT,GAAeC,SAAf,CAAyBwB,aAA/C,CACA,GAAMb,QAAS3C,WAAWyD,cAAX,EAAf,CACA,GAAIb,sBAAJ,CACA,GAAIc,gBAAiB7C,GAArB,CACA,GAAI8C,iBAAkB,KAAtB,CAGA;AACAf,eAAiBF,kBAAkBC,MAAlB,CAA0Bf,WAA1B,CAAjB,CAEA,GAAI,CAACkB,MAAMF,cAAN,CAAL,CAA4B,CACxB,GAAMK,OAAQN,OAAOM,KAAP,CAAaL,cAAb,CAAd,CACA,GAAMgB,KAAMX,MAAQrB,WAApB,CACA,GAAIgC,IAAM,CAAN,GAAYA,KAAOL,aAAP,EAAwBC,aAApC,CAAJ,CAAwD,CACpDE,eAAiBT,KAAjB,CACH,CACJ,CAED;AACA,GAAMY,iBAAkB/D,mBAAmBgE,kBAAnB,EAAxB,CACA,GAAIhB,MAAMY,cAAN,GAAyBJ,eAAzB,EAA4CS,SAASF,eAAT,CAA5C,EAAyE,CAACf,MAAMe,eAAN,CAA1E,EAAoGA,gBAAkBN,aAA1H,CAAyI,CACrIG,eAAiBM,WAAWlE,mBAAmBmE,gBAAnB,GAAsCC,OAAtC,CAA8C,CAA9C,CAAX,CAAjB,CACAP,gBAAkB,IAAlB,CACH,CAED,GAAID,eAAiB,CAAjB,EAAsB7D,sBAAwB6D,cAA9C,EAAgEA,eAAiB9B,WAAjF,EAAgG,CAACzB,kBAArG,CAAyH,CACrH,GAAMgE,iBAAkBT,eAAiB9B,WAAzC,CAEA,GAAI+B,eAAJ,CAAqB,CACjBvD,OAAOgE,IAAP,iDAA4DxC,WAA5D,QAA8E8B,cAA9E,oBAA+GS,eAA/G,EACA7E,SAAS+E,OAAT,CAAiBpD,iBAAOqD,6BAAxB,CAAuD,CACnDC,SAAUb,cADyC,CAEnDc,SAAUL,eAFyC,CAAvD,EAIH,CAND,IAMO,CACH,GAAMM,WAAY3E,mBAAmB4E,YAAnB,EAAlB,CACA,GAAMzB,QAAQL,eAAiB,CAAjB,CAAqBD,OAAOK,GAAP,CAAWJ,eAAiB,CAA5B,CAArB,CAAsDhB,WAApE,CACA,GAAM+C,YAAa,CAACF,SAAD,CAAa,CAAb,CAAiBN,gBAAkB,IAAtD,CAEAhE,mBAAqByE,OAAOC,UAAP,CAAkB,UAAM,CACzC/E,mBAAmBgF,IAAnB,CAAwBpB,cAAxB,CAAwC,IAAxC,CAA8C,IAA9C,EACAtD,OAAOgE,IAAP,4BAAuCnB,MAAvC,mBAA8DS,cAA9D,kBAA6FS,eAA7F,EACA7E,SAAS+E,OAAT,CAAiBpD,iBAAO8D,wBAAxB,CAAkD,CAC9CR,SAAUb,cADoC,CAE9Cc,SAAUL,eAFoC,CAAlD,EAIAhE,mBAAqB,IAArB,CACH,CARoB,CAQlBwE,UARkB,CAArB,CASH,CACD9E,oBAAsB6D,cAAtB,CACH,CACJ,CAEDlE,SAAW,CACPiB,WADO,CAEPK,mBAFO,CAGPT,qBAHO,CAAX,CAMAE,QAEA,MAAOf,SAAP,CACH,CAEDJ,cAAc4F,qBAAd,CAAsC,eAAtC,C,gBACeC,uBAAaC,mBAAb,CAAiC9F,aAAjC,C","file":"GapController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport Events from '../../core/events/Events';\nimport EventBus from '../../core/EventBus';\n\nconst GAP_HANDLER_INTERVAL = 100;\nconst THRESHOLD_TO_STALLS = 30;\nconst GAP_THRESHOLD = 0.1;\n\nfunction GapController() {\n    const context = this.context;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        lastPlaybackTime,\n        settings,\n        wallclockTicked,\n        gapHandlerInterval,\n        lastGapJumpPosition,\n        playbackController,\n        streamController,\n        videoModel,\n        timelineConverter,\n        adapter,\n        jumpTimeoutHandler,\n        logger;\n\n    function initialize() {\n        registerEvents();\n    }\n\n    function setup() {\n        logger = Debug(context).getInstance().getLogger(instance);\n\n        reset();\n    }\n\n    function reset() {\n        stopGapHandler();\n        unregisterEvents();\n        resetInitialSettings();\n    }\n\n    function resetInitialSettings() {\n        gapHandlerInterval = null;\n        lastGapJumpPosition = NaN;\n        wallclockTicked = 0;\n        jumpTimeoutHandler = null;\n    }\n\n    function setConfig(config) {\n        if (!config) {\n            return;\n        }\n        if (config.settings) {\n            settings = config.settings;\n        }\n        if (config.playbackController) {\n            playbackController = config.playbackController;\n        }\n        if (config.streamController) {\n            streamController = config.streamController;\n        }\n        if (config.videoModel) {\n            videoModel = config.videoModel;\n        }\n        if (config.timelineConverter) {\n            timelineConverter = config.timelineConverter;\n        }\n        if (config.adapter) {\n            adapter = config.adapter;\n        }\n    }\n\n    function registerEvents() {\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.on(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function unregisterEvents() {\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, _onWallclockTimeUpdated, this);\n        eventBus.off(Events.PLAYBACK_SEEKING, _onPlaybackSeeking, this);\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\n    }\n\n    function onBytesAppended() {\n        if (!gapHandlerInterval) {\n            startGapHandler();\n        }\n    }\n\n    function _onPlaybackSeeking() {\n        if (jumpTimeoutHandler) {\n            clearTimeout(jumpTimeoutHandler);\n            jumpTimeoutHandler = null;\n        }\n    }\n\n    function _onWallclockTimeUpdated(/*e*/) {\n        if (!_shouldCheckForGaps()) {\n            return;\n        }\n\n        wallclockTicked++;\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\n            const currentTime = playbackController.getTime();\n            if (lastPlaybackTime === currentTime) {\n                jumpGap(currentTime, true);\n            } else {\n                lastPlaybackTime = currentTime;\n                lastGapJumpPosition = NaN;\n            }\n            wallclockTicked = 0;\n        }\n    }\n\n    function _shouldCheckForGaps() {\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\n            (!playbackController.isSeeking() || streamController.hasStreamFinishedBuffering(streamController.getActiveStream())) && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\n            !streamController.getHasMediaOrIntialisationError();\n    }\n\n    function getNextRangeIndex(ranges, currentTime) {\n        try {\n\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\n                return NaN;\n            }\n            let nextRangeIndex = NaN;\n            let j = 0;\n\n            while (isNaN(nextRangeIndex) && j < ranges.length) {\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\n                    nextRangeIndex = j;\n                }\n                j += 1;\n            }\n            return nextRangeIndex;\n\n        } catch (e) {\n            return null;\n        }\n    }\n\n\n    function startGapHandler() {\n        try {\n            if (!gapHandlerInterval) {\n                logger.debug('Starting the gap controller');\n                gapHandlerInterval = setInterval(() => {\n                    if (!_shouldCheckForGaps()) {\n                        return;\n                    }\n                    const currentTime = playbackController.getTime();\n                    jumpGap(currentTime);\n\n                }, GAP_HANDLER_INTERVAL);\n            }\n        } catch (e) {\n        }\n    }\n\n    function stopGapHandler() {\n        logger.debug('Stopping the gap controller');\n        if (gapHandlerInterval) {\n            clearInterval(gapHandlerInterval);\n            gapHandlerInterval = null;\n        }\n    }\n\n    function jumpGap(currentTime, playbackStalled = false) {\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\n        const ranges = videoModel.getBufferRange();\n        let nextRangeIndex;\n        let seekToPosition = NaN;\n        let jumpToStreamEnd = false;\n\n\n        // Get the range just after current time position\n        nextRangeIndex = getNextRangeIndex(ranges, currentTime);\n\n        if (!isNaN(nextRangeIndex)) {\n            const start = ranges.start(nextRangeIndex);\n            const gap = start - currentTime;\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\n                seekToPosition = start;\n            }\n        }\n\n        // Playback has stalled before period end. We seek to the end of the period\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && timeToStreamEnd < smallGapLimit) {\n            seekToPosition = parseFloat(playbackController.getStreamEndTime().toFixed(5));\n            jumpToStreamEnd = true;\n        }\n\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition && seekToPosition > currentTime && !jumpTimeoutHandler) {\n            const timeUntilGapEnd = seekToPosition - currentTime;\n\n            if (jumpToStreamEnd) {\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${timeUntilGapEnd}`);\n                eventBus.trigger(Events.GAP_CAUSED_SEEK_TO_PERIOD_END, {\n                    seekTime: seekToPosition,\n                    duration: timeUntilGapEnd\n                });\n            } else {\n                const isDynamic = playbackController.getIsDynamic();\n                const start = nextRangeIndex > 0 ? ranges.end(nextRangeIndex - 1) : currentTime;\n                const timeToWait = !isDynamic ? 0 : timeUntilGapEnd * 1000;\n\n                jumpTimeoutHandler = window.setTimeout(() => {\n                    playbackController.seek(seekToPosition, true, true);\n                    logger.warn(`Jumping gap starting at ${start} and ending at ${seekToPosition}. Jumping by: ${timeUntilGapEnd}`);\n                    eventBus.trigger(Events.GAP_CAUSED_INTERNAL_SEEK, {\n                        seekTime: seekToPosition,\n                        duration: timeUntilGapEnd\n                    });\n                    jumpTimeoutHandler = null;\n                }, timeToWait);\n            }\n            lastGapJumpPosition = seekToPosition;\n        }\n    }\n\n    instance = {\n        reset,\n        setConfig,\n        initialize\n    };\n\n    setup();\n\n    return instance;\n}\n\nGapController.__dashjs_factory_name = 'GapController';\nexport default FactoryMaker.getSingletonFactory(GapController);\n"]}